<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从零开始绕过 DexProtector 加固的 Frida 检测 | fyrlove</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一个可复盘、可扩展、可工程化的对抗实录（本文由 id：小佳、fyrlove、roysue 共同完成） 为保证结论稳健且可迁移，文中所有实验均在以下环境中完成（LineageOS 21 &#x2F; Nexus 5X，Magisk 29.0.0，LSPosed，Zygisk Frida Gadget开源模块（https:&#x2F;&#x2F;github.com&#x2F;sucsand&#x2F;sucsand） ，Frida Ser">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始绕过 DexProtector 加固的 Frida 检测">
<meta property="og:url" content="https://fyrlove.github.io/2025/11/20/DexProtector/index.html">
<meta property="og:site_name" content="fyrlove">
<meta property="og:description" content="一个可复盘、可扩展、可工程化的对抗实录（本文由 id：小佳、fyrlove、roysue 共同完成） 为保证结论稳健且可迁移，文中所有实验均在以下环境中完成（LineageOS 21 &#x2F; Nexus 5X，Magisk 29.0.0，LSPosed，Zygisk Frida Gadget开源模块（https:&#x2F;&#x2F;github.com&#x2F;sucsand&#x2F;sucsand） ，Frida Ser">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/%E6%97%A0frida-server-%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B0%8F%E5%B7%A5%E5%85%B7-%E6%9C%AA%E8%BF%87%E6%8E%89frida%E6%A3%80%E6%B5%8B.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_24.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_3.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_4.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_5.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_6.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_7.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_8.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_9.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_10.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_12.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_13.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_22.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/%E4%BD%BF%E7%94%A8zygisk-gadget.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_23.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_14.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_15.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_16.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_17.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_18.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_20.png">
<meta property="og:image" content="https://fyrlove.github.io/images/DexProtector/img_19.png">
<meta property="article:published_time" content="2025-11-20T07:44:20.000Z">
<meta property="article:modified_time" content="2025-11-20T09:29:22.699Z">
<meta property="article:author" content="fyrlove">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fyrlove.github.io/images/DexProtector/%E6%97%A0frida-server-%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8.png">
  
    <link rel="alternate" href="/atom.xml" title="fyrlove" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fyrlove</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fyrlove.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-DexProtector" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/20/DexProtector/" class="article-date">
  <time class="dt-published" datetime="2025-11-20T07:44:20.000Z" itemprop="datePublished">2025-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      从零开始绕过 DexProtector 加固的 Frida 检测
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一个可复盘、可扩展、可工程化的对抗实录"><a href="#一个可复盘、可扩展、可工程化的对抗实录" class="headerlink" title="一个可复盘、可扩展、可工程化的对抗实录"></a>一个可复盘、可扩展、可工程化的对抗实录</h2><p>（本文由 id：小佳、fyrlove、roysue 共同完成）</p>
<p>为保证结论稳健且可迁移，文中所有实验均在以下环境中完成（LineageOS 21 &#x2F; Nexus 5X，Magisk 29.0.0，LSPosed，Zygisk Frida Gadget开源模块（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a> ，Frida Server 16.5.2）</p>
<p>合规：本文仅用于安全研究与对抗评估，旨在帮助甲方团队识别自身加固薄弱点、完善自检与回归策略；不针对具体业务落地攻击，不提供可直接用于对第三方应用的利用脚本。</p>
<p>你在这篇文章里会学到这些硬技能（都能复现）：</p>
<p>1.入口卡位：不死盯 System.loadLibrary，而是改从 __loader_android_dlopen_ext 抓“真实装载面”，提早拿到证据和时序。</p>
<p>2.匿名段定位与转储：用 JNI_OnLoad → 函数指针 → 匿名可执行段 这条线，结合 &#x2F;proc&#x2F;<pid>&#x2F;maps 找段，Frida 直接 dump，只修 text 段也能在 IDA 里反汇到可用程度。</p>
<p>3.最小化修复与类型库引入：在 IDA 里手动补区段、引 android_arm64 &#x2F; gnulnx_arm64 类型库，把 JNIEnv&#x2F;动态注册链条（RegisterNatives&#x2F;FindClass&#x2F;…）梳顺。</p>
<p>4.校验链路拆解：识别 xxHash &#x2F; SHA256 &#x2F; HMAC 的落点（含内联 SHA 指令），用“等式化替换 + 调用点定位（靠 LR 定位调用者）”做最小侵入的绕过。</p>
<p>5.二分法定位：从“可卸载点”开始逐段排除，把“必崩区间”缩到少量函数，再精确打补丁。</p>
<p>6.入口完整性绕过：遇到对“当前段基址”的校验，复制一份干净 text，参数基址替换为干净副本过检。</p>
<p>7.线程面处理：顺着 &#x2F;proc&#x2F;self&#x2F;maps 的反向引用追到 pthread_create，定位监控线程入口。</p>
<p>工程化习惯：每一步都留“能回头验证”的观测点，避免“一刀切”，降低误伤和回归压力。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="01-样本获取与安装"><a href="#01-样本获取与安装" class="headerlink" title="01.样本获取与安装"></a>01.样本获取与安装</h2><p>安装相同的版本，确保app可安装、可启动，并且能够完整复线整个过程。</p>
<h3 id="1-1-样本获取"><a href="#1-1-样本获取" class="headerlink" title="1.1 样本获取"></a>1.1 样本获取</h3><p>样本：Hyatt6.8.0.apkm<br>下载地址：下载地址：<a target="_blank" rel="noopener" href="https://www.apkmirror.com/apk/hyatt-corporation/world-of-hyatt/world-of-hyatt-6-8-0-release/world-of-hyatt-6-8-0-android-apk-download/#google_vignette">https://www.apkmirror.com/apk/hyatt-corporation/world-of-hyatt/world-of-hyatt-6-8-0-release/world-of-hyatt-6-8-0-android-apk-download/#google_vignette</a></p>
<h3 id="1-2-样本安装"><a href="#1-2-样本安装" class="headerlink" title="1.2 样本安装"></a>1.2 样本安装</h3><p>安装方法：通过 APKMirror Installer &#x2F; MT 管理器均可。</p>
<h2 id="02-设备与运行环境"><a href="#02-设备与运行环境" class="headerlink" title="02.设备与运行环境"></a>02.设备与运行环境</h2><p>该基线用于复现与对比。不同 SoC &#x2F; API level &#x2F; ART 实现可能造成“加载顺序、符号可见性、maps 标记”差异。</p>
<h3 id="2-1-设备环境"><a href="#2-1-设备环境" class="headerlink" title="2.1 设备环境"></a>2.1 设备环境</h3><p>设备：Nexus 5X（LineageOS 21）。</p>
<p>Root&#x2F;框架：Magisk 29.0.0、LSPosed、Zygisk Frida Gadget 模块（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a></p>
<p>Frida：frida-server 16.5.2。</p>
<p>PC环境: 肉丝(r0ysue)大佬提供的r0env kali虚拟机（安装了逆向需要的工具和环境配置，能省掉很多安装和环境的问题）。</p>
<h3 id="2-2-运行结果"><a href="#2-2-运行结果" class="headerlink" title="2.2 运行结果"></a>2.2 运行结果</h3><p>不运行 frida-server 时可进入主页但提示要升级；一旦 attach&#x2F;spawn，进程迅速崩溃。</p>
<p>APP点开也不会崩溃，正常进入到主页，只是强制提示必须升级到最新版才可用。说明壳可能没有root检测，或者没有检测到Magisk、LSPosed。<br><img src="/images/DexProtector/%E6%97%A0frida-server-%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8.png" alt="无frida-server-正常启动.png"></p>
<p>frida不管是attach模式还是spawn模式，均会迅速的进程崩溃退出。<br><img src="/images/DexProtector/%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B0%8F%E5%B7%A5%E5%85%B7-%E6%9C%AA%E8%BF%87%E6%8E%89frida%E6%A3%80%E6%B5%8B.png" alt="使用了小工具-未过掉frida检测.png"></p>
<h2 id="03-Java-层入口识别（Application-System-loadLibrary）"><a href="#03-Java-层入口识别（Application-System-loadLibrary）" class="headerlink" title="03.Java 层入口识别（Application &amp; System.loadLibrary）"></a>03.Java 层入口识别（Application &amp; System.loadLibrary）</h2><p>使用jadx对apk进行分析。<br>通过 AndroidManifest 与 Application 类，定位主壳入口与native 装载点，判断逻辑是否下沉到 so。</p>
<h3 id="3-1-AndroidManifest-xml文件简介"><a href="#3-1-AndroidManifest-xml文件简介" class="headerlink" title="3.1 AndroidManifest.xml文件简介"></a>3.1 AndroidManifest.xml文件简介</h3><p>Manifest 是干嘛的？</p>
<p>1.给系统登记应用身份证与四大组件（Activity&#x2F;Service&#x2F;BroadcastReceiver&#x2F;ContentProvider）。</p>
<p>2.声明权限、最低&#x2F;目标系统版本、硬件能力等。</p>
<p>3.配置应用级开关（如是否可调试、是否允许备份、网络安全配置等）。</p>
<p>其中还包含了应用的包名。这只是简述了一个大概，想了解完整的朋友请自行搜索。</p>
<h3 id="3-2-样本apk的AndroidManifest-xml分析"><a href="#3-2-样本apk的AndroidManifest-xml分析" class="headerlink" title="3.2 样本apk的AndroidManifest.xml分析"></a>3.2 样本apk的AndroidManifest.xml分析</h3><p>六十几兆的apkm文件后缀名改成zip后解压，里面有个一百多兆的base.apk，其实大部分内容都在这个base.apk里。jadx-gui打开瞅瞅。<br>1.搜<code>application</code>,找到application节点，这个节点中的name就是主壳入口点，这里是<code>ProtectedTopHyattApplication</code>类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppThemeV4.HorizontalAnimation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name_value&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.Hyatt.hyt.ProtectedTopHyattApplication&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.查找启动Activity，安卓中，启动入口的Activity会有一个intent-filter标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>搜索一下可以发现，入口Activity是SplashActivity:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/SplashTheme&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name_value&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hyt.auth.activities.SplashActivity&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.查看ProtectedTopHyattApplication类，可以看到有一些加载<code>so</code>库的操作，一般都清楚，主要逻辑一般肯定在<code>so</code>库里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">attachBaseContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.attachBaseContext(context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.a((Context) <span class="built_in">this</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;dpboot&quot;</span>);</span><br><span class="line">            wxyrq();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            b.fooldg(<span class="built_in">this</span>, th);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(Context context, String str)</span> &#123;</span><br><span class="line">            System.loadLibrary(c);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">z</span> <span class="operator">=</span> !r.a();</span><br><span class="line">            b = z;</span><br><span class="line">            <span class="keyword">if</span> (z) &#123;</span><br><span class="line">                a = <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir().getAbsolutePath());</span><br><span class="line">                r.a(context);</span><br><span class="line">                r.a(context.getFilesDir().getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>还有很多<code>native</code>函数更加验证了其逻辑在<code>java</code>层几乎没有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> InputStream <span class="title function_">BC</span><span class="params">(Object obj, String str)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">JaucCymn</span><span class="params">(String str, <span class="type">int</span> i, List list)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">byte</span>[] iIbBs();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">s</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">ttghdCr</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wxyrq</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>基本可以确定，Java层只做了引导，核心检测链条在native中。</p>
<h2 id="04-壳的native层入口点"><a href="#04-壳的native层入口点" class="headerlink" title="04.壳的native层入口点"></a>04.壳的native层入口点</h2><p>那就想先hook这个<code>System.loadLibrary</code>函数，但很明显一hook就会崩。<br>那就是要找更早的时机，hook这个<code>System.loadLibrary</code>最底层的函数，那最底层的函数是哪个呢？<br>是linker里的<code>__loader_android_dlopen_ext</code>函数。（参考文章：<a target="_blank" rel="noopener" href="https://huanle19891345.github.io/en/android/art/jni/systemloadlibrary/">SystemLoadLibrary :: 郑欢的学习总结</a><br>）<br>这个函数是全局的，直接取符号就可以。（以下都是frida16.5.2，切记先别上frida17噢）</p>
<h3 id="4-1-启动frida-server，并进行端口转发"><a href="#4-1-启动frida-server，并进行端口转发" class="headerlink" title="4.1 启动frida-server，并进行端口转发"></a>4.1 启动frida-server，并进行端口转发</h3><p>启动frida-server并指定14725，不使用默认端口(27042)，很多检测会检测这个默认端口，所以一开始就处理一下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell                                                                                                                            </span><br><span class="line">bullhead:/ $ su</span><br><span class="line">bullhead:/ # cd /data/local/tmp                                  </span><br><span class="line">bullhead:/data/local/tmp # ./frida-server  -l 0.0.0.0:14725 </span><br></pre></td></tr></table></figure>
<p>进行端口转发：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:14725 tcp:14725</span><br></pre></td></tr></table></figure>
<h3 id="4-2-hook-dlopen，定位so加载时机"><a href="#4-2-hook-dlopen，定位so加载时机" class="headerlink" title="4.2 hook dlopen，定位so加载时机"></a>4.2 hook dlopen，定位so加载时机</h3><p>执行脚本：frida -H 127.0.0.1:14725 -f com.Hyatt.hyt -l hook_dexprotect.js。<br>根据结果分析：hook 日志显示先后加载：libalice.so、libdpboot.so、libdexprotector.so；都输出了”结束”，随后崩溃。<br>崩溃时机在“加载完成之后”（非 .init_array 内）。<br>所以入口库可以基本确定为 libdexprotector.so；<br>检测不在 .init_array，后续应聚焦 JNI_OnLoad 或动态注册链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;__loader_android_dlopen_ext&quot;</span>)</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> pathptr = args[<span class="number">0</span>];</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;path is =&gt; &quot;</span>, pathptr.<span class="title function_">readCString</span>())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hook_dlopen</span>()</span><br></pre></td></tr></table></figure>

<p>运行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt; frida -H 127.0.0.1:14725 -f com.Hyatt.hyt -l hook_dexprotect.js                       </span><br><span class="line">     ____</span><br><span class="line">    / _  |   Frida 16.5.2 - A world-class dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   /_/ |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about &#x27;object&#x27;</span><br><span class="line">   . . . .       exit/quit -&gt; Exit</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at https://frida.re/docs/home/</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   Connected to 127.0.0.1:14725 (id=socket@127.0.0.1:14725)</span><br><span class="line">Spawned `com.Hyatt.hyt`. Resuming main thread!                          </span><br><span class="line">[Remote::com.Hyatt.hyt ]-&gt; path is =&gt;  libframework-connectivity-tiramisu-jni.so</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /system/framework/oat/arm64/org.apache.http.legacy.odex</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/oat/arm64/base.odex</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/split_config.arm64_v8a.apk!/lib/arm64-v8a/libalice.so</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/split_config.arm64_v8a.apk!/lib/arm64-v8a/libdpboot.so</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/split_config.arm64_v8a.apk!/lib/arm64-v8a/libdexprotector.so</span><br><span class="line">结束</span><br><span class="line">Process crashed: java.lang.RuntimeException: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029                                                                                   </span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">FATAL EXCEPTION: main</span><br><span class="line">Process: com.Hyatt.hyt, PID: 8020</span><br><span class="line">java.lang.RuntimeException: Unable to create application com.Hyatt.hyt.ProtectedTopHyattApplication: com.Hyatt.hyt.MessageGuardException_RFA6IDc4NiAwMTEyMDMyMTA1MGQwNTgwYTAxMTA3ODAyMDA1ODA2MDA3ODA4MDAxMDU4MGUwMDMwNzgwMjAwNTgwODAwNDA3ODAyMDA1ODBhMDEwMDc4MDQwMDU4MGMwMDMwNzgwMjAwNTgwNDAwMTE1MDMyMTA1MDkwNTgwYTA1NjA3ODAyMDA1ODBhMDZlMDc4MDIwMDU4MDIwMDc4MDIwMDU4MDgwYTgwMjA3ODA0MDA1ODBhMDAxMDExNjAzMjEwNTA1MDU4MGUwMzIwNzgwNjAwNTgwMjAwNzgwMjAwNTgwYzAyOSBbMjAyNTA0MjEtMjAyNTA1MjIxOTAzIGI3OmI3IDM0IGdvb2dsZS9idWxsaGVhZC9idWxsaGVhZDo4LjEuMC9PUE0zLjE3MTAxOS4wMTQvNDUwMzk5ODp1c2VyL3JlbGVhc2Uta2V5cyBibG9ja2VkXSAwMTk5ZjdjOS1hYjI5LTQ0ZGUtYmMzYi04OWI5ODk5N2RiNTg: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029</span><br><span class="line">        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7403)</span><br><span class="line">        at android.app.ActivityThread.-$$Nest$mhandleBindApplication(Unknown Source:0)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2379)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:107)</span><br><span class="line">        at android.os.Looper.loopOnce(Looper.java:232)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:317)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:8592)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:580)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:878)</span><br><span class="line">Caused by: com.Hyatt.hyt.MessageGuardException_RFA6IDc4NiAwMTEyMDMyMTA1MGQwNTgwYTAxMTA3ODAyMDA1ODA2MDA3ODA4MDAxMDU4MGUwMDMwNzgwMjAwNTgwODAwNDA3ODAyMDA1ODBhMDEwMDc4MDQwMDU4MGMwMDMwNzgwMjAwNTgwNDAwMTE1MDMyMTA1MDkwNTgwYTA1NjA3ODAyMDA1ODBhMDZlMDc4MDIwMDU4MDIwMDc4MDIwMDU4MDgwYTgwMjA3ODA0MDA1ODBhMDAxMDExNjAzMjEwNTA1MDU4MGUwMzIwNzgwNjAwNTgwMjAwNzgwMjAwNTgwYzAyOSBbMjAyNTA0MjEtMjAyNTA1MjIxOTAzIGI3OmI3IDM0IGdvb2dsZS9idWxsaGVhZC9idWxsaGVhZDo4LjEuMC9PUE0zLjE3MTAxOS4wMTQvNDUwMzk5ODp1c2VyL3JlbGVhc2Uta2V5cyBibG9ja2VkXSAwMTk5ZjdjOS1hYjI5LTQ0ZGUtYmMzYi04OWI5ODk5N2RiNTg: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.qC(Unknown Source:9)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.xDzqsetu(Unknown Source:0)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.EHo(Unknown Source:6)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.fooldg(Unknown Source:1)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.onCreate(Unknown Source:49)</span><br><span class="line">        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1386)</span><br><span class="line">        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7398)</span><br><span class="line">        ... 9 more</span><br><span class="line">Caused by: java.lang.RuntimeException: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.ttghdCr(Native Method)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$k.zeHo(Unknown Source:13)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$k.wolzmlnlx(Unknown Source:472)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.ttghdCr(Native Method)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.onCreate(Unknown Source:44)</span><br><span class="line">        ... 11 more</span><br><span class="line">***</span><br><span class="line">[Remote::com.Hyatt.hyt ]-&gt;</span><br><span class="line"></span><br><span class="line">Thank you for using Frida!</span><br></pre></td></tr></table></figure>

<h3 id="4-3-hook-JNI-OnLoad函数"><a href="#4-3-hook-JNI-OnLoad函数" class="headerlink" title="4.3 hook JNI_OnLoad函数"></a>4.3 hook JNI_OnLoad函数</h3><p>通过再去hook它的JNI_OnLoad函数。<br>发现它的JNI_OnLoad函数也很顺利执行了，但是还是死掉了。<br>我们在onLeave这里加上休眠，它是不会死的，，它可能是在JNI_OnLoad注册了JNI函数，然后外部调用的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> libdexprotector = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libdexprotector.so&quot;</span>)</span><br><span class="line">           <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libdexprotector.<span class="title function_">findExportByName</span>(<span class="string">&quot;JNI_OnLoad&quot;</span>), &#123;</span><br><span class="line">               <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;                    </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JNI_OnLoad onEnter&quot;</span>)</span><br><span class="line">               &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">                   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JNI_OnLoad  结束&quot;</span>)</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">// Thread.sleep(60)</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="/images/DexProtector/img_24.png" alt="img_24.png"></p>
<h2 id="05-定位检测函数位置，追到MMAP匿名内存段里"><a href="#05-定位检测函数位置，追到MMAP匿名内存段里" class="headerlink" title="05.定位检测函数位置，追到MMAP匿名内存段里"></a>05.定位检测函数位置，追到MMAP匿名内存段里</h2><p>检测函数应该不在init_array里面，那还有可能在JNI_OnLoad里面，或者其他native函数里面，刚刚壳的Java层看到了很多native函数，可能是Java层调过来检测的也未必。</p>
<h3 id="5-1-使用IDA分析libdexprotector-so"><a href="#5-1-使用IDA分析libdexprotector-so" class="headerlink" title="5.1 使用IDA分析libdexprotector.so"></a>5.1 使用IDA分析libdexprotector.so</h3><p>先把<code>libdexprotector.so</code>拖到IDA里分析看下，有日志可以，这个so在split_config.arm64_v8a.apk里面，前面安装包里解压出来有，再给它解压就得到<code>libdexprotector.so</code>。</p>
<p>看下<code>JNI_OnLoad</code>函数，发现啥也没干，常见的动态注册也没有，也不是没有，它是把vm传给<code>off_C838</code>这个指针函数了，让它去做事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// w0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_C830 )</span><br><span class="line">    <span class="keyword">return</span> -dword_C830;</span><br><span class="line">  v3 = off_C838(vm, <span class="number">0LL</span>);</span><br><span class="line">  off_C838 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="keyword">return</span> -v3;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65540</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>frida读下这个off_C838指针函数的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loader_android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>,<span class="string">&quot;__loader_android_dlopen_ext&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dlopen address is =&gt; &quot;</span>, loader_android_dlopen_ext)</span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(loader_android_dlopen_ext, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathptr = args[<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;path is =&gt; &quot;</span>, pathptr.<span class="title function_">readCString</span>())</span><br><span class="line">        <span class="keyword">if</span> (pathptr.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;libdexprotector.so&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">match</span> = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">ret</span>) &#123;    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>)    </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">match</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> libdexprotector = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libdexprotector.so&quot;</span>)</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libdexprotector.<span class="title function_">findExportByName</span>(<span class="string">&quot;JNI_OnLoad&quot;</span>), &#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;                    </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 is =&gt; &quot;</span>, libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>())</span><br><span class="line">                &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>跑一下结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 is =&gt;  0x7e25b9a984</span><br></pre></td></tr></table></figure>

<p>再看它属于哪个so：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 module is =&gt; &quot;</span>, <span class="title class_">Process</span>.<span class="title function_">findModuleByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>()))</span><br></pre></td></tr></table></figure>
<p>跑出来结果是null，地址不属于任何已知 module：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 module is =&gt;  null</span><br></pre></td></tr></table></figure>

<p>那么再看这个地址属于哪段内存（findRangeByAddress 显示该地址落在的匿名可执行段），为了防止进程崩溃看不到内存，加上线程休眠60秒：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 mem is =&gt; &quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>())))</span><br><span class="line"><span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>跑出来内存段是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 mem is =&gt;  &#123;<span class="string">&quot;base&quot;</span>:<span class="string">&quot;0x7e25afc000&quot;</span>,<span class="string">&quot;size&quot;</span>:507904,<span class="string">&quot;protection&quot;</span>:<span class="string">&quot;r-x&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>输出cat maps:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`cat /proc/<span class="subst">$&#123;Process.id&#125;</span>/maps | grep <span class="subst">$&#123;Process.findRangeByAddress(libdexprotector.base.add(<span class="number">0xc838</span>).readPointer()).base&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/8467/maps | grep 0x7e24570000</span><br></pre></td></tr></table></figure>

<p>把上面的结果拿去手机APP进程的maps里看下（注意去掉<code>0x7e24570000</code>这里的0x）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bullhead:/ <span class="comment"># cat /proc/8467/maps | grep 7e24570000                                                             </span></span><br><span class="line">7e24570000-7e245ec000 r-xp 00000000 00:00 0                              [anon:15f1e]</span><br></pre></td></tr></table></figure>

<p>GPT解释说，[anon:15f1e] 表示这是一段可执行的可读、私有匿名内存映射，内核为其分配的内部标识符（伪 inode）是 0x15f1e。</p>
<p>执行的函数位于这段匿名内存里，那得把它dump下来分析看看。</p>
<h3 id="5-2-IDA分析结论"><a href="#5-2-IDA分析结论" class="headerlink" title="5.2 IDA分析结论"></a>5.2 IDA分析结论</h3><p>分析到这里，可以知道，DexProtector 将关键逻辑放入运行时生成的匿名映射段；分析需转向内存态 dump与单段反汇。</p>
<h2 id="06-匿名可执行段定位与-proc-maps-交叉验证"><a href="#06-匿名可执行段定位与-proc-maps-交叉验证" class="headerlink" title="06. 匿名可执行段定位与 &#x2F;proc&#x2F;&#x2F;maps 交叉验证"></a>06. 匿名可执行段定位与 &#x2F;proc&#x2F;<pid>&#x2F;maps 交叉验证</h2><p>通过 Frida 拿到 off_C838 所在内存区 base&#x2F;size&#x2F;prot，再交叉 cat &#x2F;proc&#x2F;<pid>&#x2F;maps 验证段属性与范围。<br>Frida转储dump匿名内存：<br>使用frida直接输出一下进程号pid：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 pid is =&gt; &quot;</span>,<span class="title class_">Process</span>.<span class="property">id</span>)</span><br></pre></td></tr></table></figure>
<p>这样就直接有了内存段的起始地址，长度，进程号，再使用线程休眠，把APP卡主使其不闪退：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">off_C838 mem is =&gt;  &#123;<span class="string">&quot;base&quot;</span>:<span class="string">&quot;0x7e25afc000&quot;</span>,<span class="string">&quot;size&quot;</span>:507904,<span class="string">&quot;protection&quot;</span>:<span class="string">&quot;r-x&quot;</span>&#125;</span><br><span class="line">off_C838 pid is =&gt;  8601</span><br></pre></td></tr></table></figure>
<p>如果手速较慢，可以把休眠时间设置为更长。配合以下dump脚本，把匿名内存脱下来：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line">js_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function dump_anon() &#123;</span></span><br><span class="line"><span class="string">    console.log(&quot;开始dump&quot;)</span></span><br><span class="line"><span class="string">    const base = ptr(0x7e25afc000);</span></span><br><span class="line"><span class="string">    const module_size = 507904;</span></span><br><span class="line"><span class="string">    Memory.protect(base, module_size, &#x27;rwx&#x27;);</span></span><br><span class="line"><span class="string">    const soMemory = Memory.readByteArray(base, module_size);</span></span><br><span class="line"><span class="string">    send(&#123;name: &quot;libanon.so&quot;, base: base, size: module_size&#125;, soMemory);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">dump_anon()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        payload = message[<span class="string">&#x27;payload&#x27;</span>]</span><br><span class="line">        so_name = payload[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        base_address = payload[<span class="string">&#x27;base&#x27;</span>]</span><br><span class="line">        size = payload[<span class="string">&#x27;size&#x27;</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Dumping <span class="subst">&#123;so_name&#125;</span> (Base: <span class="subst">&#123;base_address&#125;</span>, Size: <span class="subst">&#123;size&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="comment"># 保存dump的.so文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(so_name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;so_name&#125;</span> dumped successfully!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 附加到目标进程</span></span><br><span class="line">    device = frida.get_usb_device()</span><br><span class="line">    session = device.attach(<span class="number">8601</span>)</span><br><span class="line">    <span class="comment"># 加载Frida脚本</span></span><br><span class="line">    script = session.create_script(js_script)</span><br><span class="line">    <span class="comment"># 设置消息处理函数</span></span><br><span class="line">    script.on(<span class="string">&quot;message&quot;</span>, on_message)</span><br><span class="line">    <span class="comment"># 加载并执行脚本</span></span><br><span class="line">    script.load()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;dumpso.py</span><br><span class="line">开始dump</span><br><span class="line">Dumping libanon.so (Base: 0x7e25afc000, Size: 507904)</span><br><span class="line">libanon.so dumped successfully!</span><br></pre></td></tr></table></figure>
<p>脱下来的libanon.so位于当前执行脚本的目录下。</p>
<h2 id="07-IDA手修匿名内存SO"><a href="#07-IDA手修匿名内存SO" class="headerlink" title="07.IDA手修匿名内存SO"></a>07.IDA手修匿名内存SO</h2><p>拖到010 editor里去可以看到前面一大片都是0，也就是没有ELF的文件头，果然是匿名内存段的风格。大概率也sofix没法修。<br>拖到IDA里，IDA也无法判断这是什么汇编格式，手动选择一个处理器类型：ARM Little-endian ，点击确定。<br><img src="/images/DexProtector/img_3.png" alt="img_3.png"><br>一路点击确定，按照ARM默认设置来分析这段匿名内存so。此时IDA左边已经有了一堆<code>sub_</code>符号，说明IDA是可以正常分析里面的函数的。<br>说明哪怕只有一个text段，IDA也是可以正常反汇编的，哪怕没有导入导出表，没有文件头没有符号表，没有其他区段，也没有关系。<br>接下来开始做基础修复，视图→打开子视图→类型库，导入基础库，右键，加载类型库，导入<code>android_arm64</code>库，和<code>gnulnx_arm64</code>，前者是安卓的，后者是C++的。导进去才能识别<code>JNI</code>的东西，才能有JNIEnv和jclass这些，后续要改参数类型识别JNI里面的函数如RegisterNatives、FindClass那些。<br><img src="/images/DexProtector/img_4.png" alt="img_4.png"></p>
<h2 id="08-IDA手修匿名内存SO-2-匿名指针函数代码追踪"><a href="#08-IDA手修匿名内存SO-2-匿名指针函数代码追踪" class="headerlink" title="08.IDA手修匿名内存SO(2),匿名指针函数代码追踪"></a>08.IDA手修匿名内存SO(2),匿名指针函数代码追踪</h2><p>以 ARM64 Little-endian 打开；导入 android_arm64 &#x2F; gnulnx_arm64 类型库以恢复 JNI&#x2F;GLIBC 符号语义；</p>
<p>手工增加 rodata 等伪区段解决“无效内存访问”。</p>
<h3 id="8-1-寻找真实执行的函数"><a href="#8-1-寻找真实执行的函数" class="headerlink" title="8.1 寻找真实执行的函数"></a>8.1 寻找真实执行的函数</h3><p>到这里还没找到前面实际执行的<code>off_C838</code>函数在哪里，可以把函数指针地址减去基地址即可得到真实的偏移。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 real offset =&gt; &quot;</span>,libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>().<span class="title function_">sub</span>(<span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>()).<span class="property">base</span>))</span><br></pre></td></tr></table></figure>
<p>执行一下，也就是sub_4e984。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 real offset =&gt;  0x4e984</span><br></pre></td></tr></table></figure>

<h3 id="8-2-无效内存访问修复"><a href="#8-2-无效内存访问修复" class="headerlink" title="8.2 无效内存访问修复"></a>8.2 无效内存访问修复</h3><p>在IDA里按g跳到0x4e984的地址，就是sub_4e984的函数头，按F5汇编即可开始分析。<br>首先有些报红字的，无效内存访问报错：<br><img src="/images/DexProtector/img_5.png" alt="img_5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MEMORY[0x8A800] = v1;</span><br><span class="line">MEMORY[0x8A808] = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 168LL))(v7, v6);</span><br></pre></td></tr></table></figure>
<p>其实就是dump下来的so里没有数据段的原因，视图→打开子视图→区段，右键→添加区段，区段名称可以取rodata，开始地址可以填0x8A800，结束地址0x8B800，给大一些。后面再遇到红字的，可以继续扩大一些，覆盖到红字指向地址的范围即可。<br>再回到sub_4e984函数再按一下F5，红字就消失了，变成了：<br><img src="/images/DexProtector/img_6.png" alt="img_6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unk_8A800 = v1;</span><br><span class="line">unk_8A808 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 168LL))(v7, v6);</span><br></pre></td></tr></table></figure>
<p>点在<code>unk_8A800</code>上按x，就可以追踪交叉引用了，可以看到有四处引用到这个地址:<br><img src="/images/DexProtector/img_7.png" alt="img_7.png"><br>前面JNIOnLoad里面就一个vm参数传到off_C838了，那这里<code>sub_4e984</code>参数类型就是<code>JavaVM*</code>，按y修改。修改成功后，一些指针也会从这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*(<span class="type">unsigned</span> <span class="type">int</span> (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)a1 + <span class="number">48LL</span>))(a1, &amp;v7, <span class="number">65540</span>) )</span><br></pre></td></tr></table></figure>
<p>变成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*a1)-&gt;GetEnv(a1, (<span class="type">void</span> **)&amp;v8, <span class="number">65540LL</span>) )</span><br></pre></td></tr></table></figure>
<p>完整的结果：<br><img src="/images/DexProtector/img_8.png" alt="img_8.png"><br>识别出来了env里的指针，这也是前面导入库发挥了作用。<br>接下来即可进行基本的逐行手撕了，以及不停地做一些尝试绕过检测的hook了。在逆向中也是这样不断地做尝试的。<br>接下来理论上要进行全量分析了，逆向到最后，归根结底都是体力活罢了。</p>
<h2 id="09-JNIEnv-恢复与动态注册链梳理"><a href="#09-JNIEnv-恢复与动态注册链梳理" class="headerlink" title="09.JNIEnv 恢复与动态注册链梳理"></a>09.JNIEnv 恢复与动态注册链梳理</h2><p>逐行手撕定位敏感函数</p>
<h3 id="9-1-JNIEnv-恢复"><a href="#9-1-JNIEnv-恢复" class="headerlink" title="9.1 JNIEnv 恢复"></a>9.1 JNIEnv 恢复</h3><p>继续分析<code>sub_4e984</code>，a1获取env传给v7了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*a1)-&gt;GetEnv(a1, (<span class="type">void</span> **)&amp;v7, <span class="number">65540</span>) </span><br></pre></td></tr></table></figure>
<p>那v7的参数类型就是JNIEnv*，在定义那里<code>__int64 v8;</code>按y修改一下参数类型。原本的几个不明意义的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">136LL</span>))(v7);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(v3 + <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = sub_4EBE0(v7);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = v4;</span><br><span class="line">      <span class="keyword">if</span> ( !(*(<span class="type">unsigned</span> __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">1824LL</span>))(v7) )</span><br><span class="line">        sub_4EFC4(v7, v5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(<span class="type">unsigned</span> __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">1824LL</span>))(v7) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">120LL</span>))(v7);</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">136LL</span>))(v7);</span><br><span class="line">      unk_8A808 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + <span class="number">168LL</span>))(v7, v6);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>修改成功后，又变得有意义了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">&#123;</span><br><span class="line">  (*v7)-&gt;ExceptionClear(v7);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(v3 + <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v4 = sub_4EBE0(v7);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( !(*v7)-&gt;ExceptionCheck(v7) )</span><br><span class="line">      sub_4EFC4(v7, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (*v7)-&gt;ExceptionCheck(v7) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (__int64)(*v7)-&gt;ExceptionOccurred(v7);</span><br><span class="line">    (*v7)-&gt;ExceptionClear(v7);</span><br><span class="line">    unk_8A808 = (*v7)-&gt;NewGlobalRef(v7, (jobject)v6);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-动态注册链路梳理，函数分析，发现重点可疑目标"><a href="#9-2-动态注册链路梳理，函数分析，发现重点可疑目标" class="headerlink" title="9.2 动态注册链路梳理，函数分析，发现重点可疑目标"></a>9.2 动态注册链路梳理，函数分析，发现重点可疑目标</h3><p>从上往下看，接下来它把v8这个<code>jnienv</code>依次传给了<code>sub_4EAA0</code>、<code>sub_4EBE0</code>、<code>sub_4EFC4</code>这几个函数，这些函数都要跟进去逐行查看，每一行到底做了什么。<br>先看第一个<code>sub_4EAA0</code>，唯一的参数a1修改类型为<code>JNIEnv*</code>，下面立刻动态注册的API出来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint (*RegisterNatives)(JNIEnv *, jclass, <span class="type">const</span> JNINativeMethod *, jint); </span><br></pre></td></tr></table></figure>
<p>动态注册的函数列表保存在v6参数中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v6[<span class="number">0</span>] = v9;</span><br><span class="line">v6[<span class="number">1</span>] = sub_40814(&amp;unk_681F);</span><br><span class="line">v6[<span class="number">2</span>] = sub_4F0F4;</span><br><span class="line">v6[<span class="number">3</span>] = v8;</span><br><span class="line">v6[<span class="number">4</span>] = sub_40814(&amp;unk_346B);</span><br><span class="line">v6[<span class="number">5</span>] = sub_4F254;</span><br><span class="line">v6[<span class="number">6</span>] = v7;</span><br><span class="line">v4 = sub_40814(&amp;unk_5523);</span><br><span class="line">RegisterNatives = (*a1)-&gt;RegisterNatives;</span><br><span class="line">v6[<span class="number">7</span>] = v4;</span><br><span class="line">v6[<span class="number">8</span>] = MEMORY[<span class="number">0x82988</span>];</span><br><span class="line"><span class="keyword">if</span> ( RegisterNatives(a1, (jclass)v3, (<span class="type">const</span> JNINativeMethod *)v6, <span class="number">3</span>) )</span><br></pre></td></tr></table></figure>
<p>其中<code>sub_4F0F4</code>开辟了一段字节数组，像是初始化函数，先不看。<br><code>sub_4F254</code>特别长，业务逻辑十分丰富，还夹杂着很多Java类方法的使用，大概五六百行，一眼看不出逻辑，需要细细拆分研究。这里是接下来分析的重点。</p>
<h2 id="10-关键函数-sub-4F254-的行为探测（返回值与入栈点）"><a href="#10-关键函数-sub-4F254-的行为探测（返回值与入栈点）" class="headerlink" title="10.关键函数 sub_4F254 的行为探测（返回值与入栈点）"></a>10.关键函数 sub_4F254 的行为探测（返回值与入栈点）</h2><p>直接hook这个sub_4F254，观察一下结果，并首次尝试修改结果过检测：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x4F254</span>),&#123;</span><br><span class="line">     <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x4F254 &quot;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onLeave  0x4F254  &quot;</span>,retval.<span class="title function_">toInt32</span>())   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onEnter  0x4F254 </span><br><span class="line">onEnter  0x4F254 </span><br><span class="line">onLeave  0x4F254   0</span><br><span class="line">onLeave  0x4F254   1</span><br></pre></td></tr></table></figure>
<p>尝试修改返回值为0，测试是否能过掉检测：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x4F254</span>),&#123;</span><br><span class="line">     <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x4F254 &quot;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        retval.<span class="title function_">replace</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onLeave  0x4F254  &quot;</span>,retval.<span class="title function_">toInt32</span>())   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>返回值修改为0，成功。但是app依然崩溃了，果然，一切不会这么简单。继续分析中间的逻辑，检测大概率就是在中间的逻辑完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onEnter  0x4F254 </span><br><span class="line">onEnter  0x4F254 </span><br><span class="line">onLeave  0x4F254   0</span><br><span class="line">onLeave  0x4F254   0</span><br></pre></td></tr></table></figure>
<p>必须深入其内部校验路径（而非仅“短路返回”）——尤其是完整性&#x2F;哈希相关分支。</p>
<h2 id="11-浮点运算特征联合GPT定位CRC哈希算法"><a href="#11-浮点运算特征联合GPT定位CRC哈希算法" class="headerlink" title="11.浮点运算特征联合GPT定位CRC哈希算法"></a>11.浮点运算特征联合GPT定位CRC哈希算法</h2><p>进这个<code>sub_4F254</code>函数，从上往下看，第一个可疑的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v34 == sub_161E8(unk_82948, unk_82990 - unk_82948, &amp;v75) )</span><br><span class="line">    sub_14D24(byte_872AC, <span class="number">64</span>, v32, <span class="number">32</span>, v33);</span><br></pre></td></tr></table></figure>
<p>点进<code>sub_161E8</code>函数，可以看到大量浮点数寄存器，<code>vaddq_s64</code>、<code>veorq_s8</code>、<code>vorrq_s8</code>，一般这种不是哈希就是加解密，再结合函数开头就有一些初始常量，大概率是哈希：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v12 = v10 ^ <span class="number">0x7465646279746573L</span>L;</span><br><span class="line">v13 = v10 ^ <span class="number">0x646F72616E646F6DL</span>L;</span><br><span class="line">v14 = a2 &lt;&lt; <span class="number">56</span>;</span><br><span class="line">v15 = *a3 ^ <span class="number">0x6C7967656E657261L</span>L;</span><br><span class="line">v16 = *a3 ^ <span class="number">0x736F6D6570736575L</span>L;</span><br></pre></td></tr></table></figure>
<p>其实猜算法这件事情，最拿手的应该是GPT，直接整个F5全部复制黏贴过去问GPT，GPT告诉我这很像是SipHash哈希算法的实现，具体是 SipHash-2-4 变种（2轮压缩，4轮最终化），真假先不做评价，先hook看下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> libanon = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>()).<span class="property">base</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x161E8</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>)</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 leave&quot;</span>,ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>单纯hook结果没什么特别：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub_161E8 enter</span><br><span class="line">sub_161E8 leave 0xff4414fe9bf00ecd</span><br><span class="line">sub_161E8 enter</span><br><span class="line">sub_161E8 leave 0xff4414fe9bf00ecd</span><br></pre></td></tr></table></figure>
<p>但从结果来看这里其实是做crc哈希校验的地方。sub_161E8 属于完整性哈希链路；但仅满足判等未必足以阻断后续自校验&#x2F;熔断。</p>
<h2 id="12-HMAC-SHA256-路径确认（内联-SHA-指令识别）"><a href="#12-HMAC-SHA256-路径确认（内联-SHA-指令识别）" class="headerlink" title="12.HMAC-SHA256 路径确认（内联 SHA 指令识别）"></a>12.HMAC-SHA256 路径确认（内联 SHA 指令识别）</h2><p>全局hex搜挂哈希魔术定位CRC校验</p>
<h3 id="12-1-分析定位-HMAC-SHA256"><a href="#12-1-分析定位-HMAC-SHA256" class="headerlink" title="12.1 分析定位 HMAC-SHA256"></a>12.1 分析定位 HMAC-SHA256</h3><p>问了下GPT，<code>0xff4414fe9bf00ecd</code>这个值看起来像是一个64位的哈希值（16个十六进制字符 * 4位&#x2F;字符 &#x3D; 64位）。根据其长度和格式，它最有可能来自以下几种哈希算法：</p>
<ul>
<li>xxHash: 一个极快的非加密哈希算法，64位版本会生成一个16字符的十六进制值。这是一个非常强有力的候选。</li>
<li>MurmurHash3: 另一个经典的非加密哈希函数，其128位版本更常见，但它也有64位的变体。</li>
<li>CityHash, FarmHash: 由Google发布的哈希函数系列，用于类似的目的，能产生64位哈希。</li>
<li>SipHash: 虽然也是64位输出，但它更注重防止哈希洪水攻击，常用在编程语言的字典实现中（如Python、Ruby）。<br>当然如果是结果导向的话，逆完之后发现是<code>xxHash</code>算法。</li>
<li></li>
</ul>
<p>继续回到<code>sub_4F254</code>里面，如果返回值与v34相等，则会进入<code>sub_14D24</code>，那再进入<code>sub_14D24</code>看下做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v34 = unk_8A810;</span><br><span class="line"><span class="keyword">if</span> ( v34 == sub_161E8(unk_82948, unk_82990 - unk_82948, &amp;v75) )</span><br><span class="line">    sub_14D24(byte_872AC, <span class="number">64</span>, v32, <span class="number">32</span>, v33);</span><br></pre></td></tr></table></figure>
<p>在<code>sub_14D24</code>里面可以看到，<code>sub_2FA44</code>做了一些初始化，<code>sub_304A8</code>、<code>sub_30B14</code>里面则演都不演了，直接内联汇编了SHA256的算法，也可能是编译优化的产物，为了加快运行速度。<br><img src="/images/DexProtector/img_9.png" alt="img_9.png"><br>两次<code>SHA256</code>的计算，那合理猜测是做的<code>HMAC</code>算法，合理猜测<code>sub_14D24</code>就是<code>HMAC</code>的入口。</p>
<h3 id="12-2-通过010editor，快速查找使用了sha256的函数"><a href="#12-2-通过010editor，快速查找使用了sha256的函数" class="headerlink" title="12.2 通过010editor，快速查找使用了sha256的函数"></a>12.2 通过<code>010editor</code>，快速查找使用了sha256的函数</h3><p>打开IDA的选项→常规，操作码字节数改成8，点确定，随便找个<code>SHA256</code>里面已经优化好的汇编，看下操作码，比如这一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM:<span class="number">0000000000030708</span> <span class="number">83</span> <span class="number">28</span> <span class="number">28</span> <span class="number">5</span>E   SHA256SU0       V3.<span class="number">4</span>S, V4.<span class="number">4</span>S</span><br></pre></td></tr></table></figure>
<p>就是<code>8328285E</code>，把<code>linanon.so</code>文件拖到<code>010 editor</code>里面去，全局搜这个二进制，可以得到如图12处结果。<br>复制行号，到IDA里去看了下，前六处属于刚刚的<code>sub_304A8</code>函数，后六处属于<code>sub_30B14</code>函数，也就是一共就俩函数进行SHA256校验。</p>
<h2 id="13-等式化替换策略：让-CRC-Hash“必相等”"><a href="#13-等式化替换策略：让-CRC-Hash“必相等”" class="headerlink" title="13.等式化替换策略：让 CRC&#x2F;Hash“必相等”"></a>13.等式化替换策略：让 CRC&#x2F;Hash“必相等”</h2><p>基于 lr 获取调用点（0x4f5a4 &#x2F; 0x4f6cc &#x2F; 0x5c494），对 sub_161E8 的返回值在不同入栈点替换为预期内存值（0x8A810&#x2F;0x8AB20）以通过等式校验。</p>
<h3 id="13-1-HMAC-SHA256入口函数分析"><a href="#13-1-HMAC-SHA256入口函数分析" class="headerlink" title="13.1 HMAC-SHA256入口函数分析"></a>13.1 <code>HMAC-SHA256</code>入口函数分析</h3><p>再回到<code>sub_14D24</code>可以发现，先调用了<code>sub_304A8</code>函数之后，又立即调用了<code>sub_30B14</code>，也就是<code>sub_14D24</code>应该是<code>HMAC-SHA256</code>的入口。<br>那同样hook看下有没有经过<code>sub_14D24</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(libanon.base.add(<span class="number">0x14D24</span>),&#123;</span><br><span class="line">    onEnter:function(args)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;sub_14D24 enter&quot;</span>,this.context.lr.sub(libanon.base))</span><br><span class="line">    &#125;,onLeave:function(ret)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;sub_14D24 leave&quot;</span>,ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_14D24 enter 0x4ee38</span><br><span class="line">sub_14D24 leave 0x7ff213aa70</span><br></pre></td></tr></table></figure>
<p>而此处调用的汇编地址是<code>0x4F5C8</code>，也就是<code>sub_4F254+354</code>处，很明显不是<code>0x4ee38</code>，也就是此处没有进入执行<code>sub_14D24</code>的逻辑。<br><img src="/images/DexProtector/img_10.png" alt="img_10.png"></p>
<h3 id="13-2-HOOK绕过CRC校验使其相等"><a href="#13-2-HOOK绕过CRC校验使其相等" class="headerlink" title="13.2 HOOK绕过CRC校验使其相等"></a>13.2 HOOK绕过CRC校验使其相等</h3><p>那如何让它进入呢？只要<code>v34</code>与<code>sub_161E8</code>运行的结果相等即可进入。这其实就是一段CRC的内存校验，可以写个脚本来使其相等。<br>首先看下有哪些地方对<code>sub_161E8</code>进行了校验，前面的代码加上一句<code>lr</code>返回值地址的输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>,<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>))</span><br></pre></td></tr></table></figure>

<p>跑一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub_161E8 enter 0x4f5a4</span><br><span class="line">sub_161E8 leave 0x7799165d5282bf95</span><br><span class="line">sub_161E8 enter 0x4f6cc</span><br><span class="line">sub_161E8 leave 0x7799165d5282bf95</span><br></pre></td></tr></table></figure>
<p>两处进行了校验，<code>0x4f5a4</code>和<code>0x4f6cc</code>处，那就把这两处的返回值都看一下，要等于哪处内存的值，才能进入相等后的逻辑：<br>通过x查找引用，发现还有一个地方也使用sub_161E8做了比较<code>0x5C494</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash_crc = &#123;</span><br><span class="line">        <span class="string">&quot;0x4f5a4&quot;</span> : <span class="number">0x8A810</span>,</span><br><span class="line">        <span class="string">&quot;0x4f6cc&quot;</span> : <span class="number">0x8A810</span>,</span><br><span class="line">        <span class="string">&quot;0x5c494&quot;</span> : <span class="number">0x8AB20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终完整的相等逻辑代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="title function_">add</span>(<span class="number">0x161E8</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>,<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon))</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon)</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()])&#123;</span><br><span class="line">            ret.<span class="title function_">replace</span>(libanon.<span class="title function_">add</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()]).<span class="title function_">readU64</span>())</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 leave&quot;</span>,ret)</span><br><span class="line">        &#125;                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>为何<code>lr</code>寄存器要使用<code>onEnter</code>时机的而不能是<code>onLeave</code>时机的？因为frida在hook替换的时候已经把lr修改的面目全非了，这涉及到native hook的调用顺序和核心原理，可以问问GPT，这里不再赘述。所以得保留原来的lr才是正确的。<br>跑一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub_14D24 enter 0x4ee38</span><br><span class="line">sub_14D24 leave 0x7ff213aa70</span><br><span class="line">sub_161E8 enter 0x4f5a4</span><br><span class="line">sub_161E8 leave 0x40a05af38cb96159</span><br><span class="line">sub_14D24 enter 0x4f5c8</span><br><span class="line">sub_14D24 leave 0x7ff2139460</span><br><span class="line">sub_161E8 enter 0x4f6cc</span><br><span class="line">sub_161E8 leave 0x40a05af38cb96159</span><br></pre></td></tr></table></figure>
<p>很明显替换成功了，<code>sub_161E8</code>返回值由<code>0x7799165d5282bf95</code>替换成了<code>0x40a05af38cb96159</code>，且进入了<code>0x4f5c8</code>处的<code>sub_14D24</code>函数计算逻辑。<br>只是很不幸，还是没能绕过，进程还是崩溃了。胜败乃兵家常事，英雄请重新来过。</p>
<p>SO里的每一行汇编都要扒光，要让它没有秘密。全扒光就拥有了维多利亚的秘密。</p>
<p>该策略仅能跨过“第一道门”，后续仍有追加校验&#x2F;副通道检测（如 maps 轮询 &#x2F; 线程监控）。</p>
<h2 id="14-字符串解密链与-proc-self-maps-检测点确认"><a href="#14-字符串解密链与-proc-self-maps-检测点确认" class="headerlink" title="14.字符串解密链与 &#x2F;proc&#x2F;self&#x2F;maps 检测点确认"></a>14.字符串解密链与 &#x2F;proc&#x2F;self&#x2F;maps 检测点确认</h2><p>分析发现字符串处理，关键信息</p>
<h3 id="14-1-发现字符串检测"><a href="#14-1-发现字符串检测" class="headerlink" title="14.1 发现字符串检测"></a>14.1 发现字符串检测</h3><p>sub_50130-&gt;修改a1类型为JNIEnv之后，发现调用了字符串的方法：<br><img src="/images/DexProtector/img_12.png" alt="img_12.png"><br>v4是一个类，传入了v19，那么猜测sub_55650可能是一个字符串解密的函数，下面的sub_40814似乎也是一个字符串揭秘函数，<br>那么接下来直接hook它们</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sub_55650(&amp;unk_87419, v19, <span class="number">257</span>);</span><br><span class="line">  v4 = (*a1)-&gt;FindClass(a1, v19);</span><br><span class="line">  <span class="keyword">if</span> ( (*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">46</span>;</span><br><span class="line">  v5 = (<span class="type">void</span> *)sub_3CF88();</span><br><span class="line">  sub_55650(&amp;unk_87218, v18, <span class="number">65</span>);</span><br><span class="line">  GetStaticMethodID = (*a1)-&gt;GetStaticMethodID;</span><br><span class="line">  v7 = sub_40814(dword_346B, &amp;v16, <span class="number">22</span>);</span><br><span class="line">  v8 = GetStaticMethodID(a1, v5, v18, v7);</span><br><span class="line">  <span class="keyword">if</span> ( (*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">46</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v11 = (*a1)-&gt;ToReflectedMethod(a1, v5, v8, <span class="number">1</span>);</span><br><span class="line">    sub_55650(&amp;unk_872F5, v17, <span class="number">65</span>);</span><br><span class="line">    v12 = (*a1)-&gt;GetStaticMethodID;</span><br><span class="line">    v13 = sub_40814(dword_3EC3, &amp;v15, <span class="number">24</span>);</span><br><span class="line">    v14 = v12(a1, v4, v17, v13);</span><br><span class="line">    v9 = <span class="number">46</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      (*a1)-&gt;CallStaticVoidMethod(a1, v4, v14, v11, a2);</span><br><span class="line">      <span class="keyword">if</span> ( (*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">46</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x55650</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x55650]&quot;</span>,retval.<span class="title function_">readCString</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//Interceptor.attach(libanon.base.add(0x40814),&#123; //0x40814这个函数内部做了inlinehook，直接这样hook，就崩溃了</span></span><br><span class="line"><span class="comment">//那么这个我们可以偏移4条指令进行hook </span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x40814</span>+ <span class="number">4</span>*<span class="number">4</span>),&#123; </span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(libanon.<span class="property">base</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">lr</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x40814]&quot;</span>,retval.<span class="title function_">readCString</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x40814]&quot;</span>,retval.<span class="title function_">readCString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：<br><img src="/images/DexProtector/img_13.png" alt="img_13.png"></p>
<h3 id="14-2-通过输出的libart-so的地址，找到调用函数，并修改返回值"><a href="#14-2-通过输出的libart-so的地址，找到调用函数，并修改返回值" class="headerlink" title="14.2 通过输出的libart.so的地址，找到调用函数，并修改返回值"></a>14.2 通过输出的libart.so的地址，找到调用函数，并修改返回值</h3><p>分析这个结果，发现检测了分段maps,这里通过libart.so的0x61a78去找到函数进行hook，检测一般都是通过这里进行。<br>在ida中g这个0x61a78，找到调用的函数为sub_61974，hook这个看一下结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x61974</span>),&#123; </span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;      </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x61974]&quot;</span>,retval.<span class="title function_">toInt32</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果，发现返回值是786。在ida中分析sub_61974，返回值786是出现了异常，正常返回应该是v1&#x3D;0，那么我们这里hook替换一下返回值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x61974 =&gt;  786  lr =&gt;  0x4f630</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这里修改返回之后，运行依然崩溃了，但是日志输出要比之前多一些了。<br>说明 maps 检测非唯一触发，且与其他面耦合。</p>
<h2 id="15-二分排除法缩窗（定位“必崩区间”）"><a href="#15-二分排除法缩窗（定位“必崩区间”）" class="headerlink" title="15.二分排除法缩窗（定位“必崩区间”）"></a>15.二分排除法缩窗（定位“必崩区间”）</h2><p>注意，这里开始，我们切换Zygisk Frida Gadget，使用方法在这里（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a> ，绕过一部分基于ptrace的检测，并开始使用二分排除法，来定位出问题的地方。<br>将“必崩窗口”缩至少量函数，有利于后续精确打补丁。</p>
<h3 id="15-1-使用Zygisk-Frida-Gadget模块"><a href="#15-1-使用Zygisk-Frida-Gadget模块" class="headerlink" title="15.1 使用Zygisk Frida Gadget模块"></a>15.1 使用Zygisk Frida Gadget模块</h3><p>注意:从frida-server换到Zygisk Frida Gadget模块后，重启一下手机。使用Zygisk Frida Gadget的时候，要先正常启动过一次app。<br>在sucsand中，勾选酒店app，并设置200延迟。<br><img src="/images/DexProtector/img_22.png" alt="img_22.png"></p>
<p>配置完成后，在桌面的酒店应用图标长按，然后点强行停止，然后再重新打开app，此时app启动会被阻塞：<br><img src="/images/DexProtector/%E4%BD%BF%E7%94%A8zygisk-gadget.png" alt="使用zygisk-gadget.png"><br>现在开始使用frida -H 192.168.0.101:9999 -F -l dexprotect2.js 来执行脚本。9999是模块内置的端口号。<br><img src="/images/DexProtector/img_23.png" alt="img_23.png"></p>
<h3 id="15-2-继续分析检测点"><a href="#15-2-继续分析检测点" class="headerlink" title="15.2 继续分析检测点"></a>15.2 继续分析检测点</h3><p>继续往下分析sub_4F254，现在都是体力活儿，只能挨着往下分析，看着确实无聊。</p>
<p>现在来到了sub_27398,这里看着像是在做检测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v41 = sub_27398(v39, &amp;v70, <span class="number">32</span>, &amp;v69, <span class="number">8</span>, &amp;v68, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)v68 != unk_872EC</span><br><span class="line">  || BYTE1(v68) != unk_872ED</span><br><span class="line">  || BYTE2(v68) != unk_872EE</span><br><span class="line">  || HIBYTE(v68) != unk_872EF )</span><br><span class="line">&#123;</span><br><span class="line">  sub_62F48(<span class="number">11</span>);</span><br><span class="line">  v41 = sub_62F74(&amp;v68, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">v24 = v74;</span><br><span class="line"><span class="keyword">if</span> ( !v74 )</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x27398</span>),&#123;     <span class="comment">//fail</span></span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x27398 &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>)</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">detachAll</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x27398] &quot;</span>,retval.<span class="title function_">toInt32</span>(),<span class="string">&quot;lr&quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在这里执行全部卸载，发现还是崩溃了，说明在这里之前就已经对整个内存进行检测了，那么我们要找一个没有检测的点，来缩小排查范围。<br>找这个点的原则是，这个函数只调用了一次，并且卸载后能保证app顺利运行。<br>4F254 ，可以<br>593FC ，可以<br>27398 ，不行<br>那么就可以确定， 问题出在593FC~27398之间。那么我们又从这个中间的函数开始进行排查，一步一步缩小位置：<br>3EA0C ，可以<br>15128 ，不行<br>那么现在进一步缩小到了3EA0C～15128之间，分析的范围大大减小了：<br><img src="/images/DexProtector/img_14.png" alt="img_14.png"><br>进一步分析，sub_14F7C，没有看出什么问题，暂时排除。</p>
<p>目前这些函数都没有分析出什么有效的信息。</p>
<h2 id="16-入口校验绕过（复制-text-→-替换参数基址）"><a href="#16-入口校验绕过（复制-text-→-替换参数基址）" class="headerlink" title="16.入口校验绕过（复制 text → 替换参数基址）"></a>16.入口校验绕过（复制 text → 替换参数基址）</h2><p>在没有什么有效信息的情况下，当一次侥幸哥，进行暴力拆解</p>
<h3 id="16-1-发现对入口函数进行了检测"><a href="#16-1-发现对入口函数进行了检测" class="headerlink" title="16.1 发现对入口函数进行了检测"></a>16.1 发现对入口函数进行了检测</h3><p>上面分析出来的sha256的sub_304A8，来hook一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x304A8</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x304A8 &quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],<span class="string">&quot;base &quot;</span>,rangeDetails.<span class="property">base</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：<br><img src="/images/DexProtector/img_15.png" alt="img_15.png"><br>通过分析结果，发现304A8，对入口的函数也做了检测</p>
<h3 id="16-2-处理对入口函数检测"><a href="#16-2-处理对入口函数检测" class="headerlink" title="16.2 处理对入口函数检测"></a>16.2 处理对入口函数检测</h3><p>针对 sub_304A8 的入口校验：</p>
<p>先把匿名段 text 拷贝一份 origin；</p>
<p>若发现其校验针对当前段基址，则把参数中的基址替换为 origin（干净副本）以规避校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> origin</span><br><span class="line"><span class="keyword">var</span> size=<span class="number">0x7a2a0</span></span><br><span class="line"></span><br><span class="line">origin = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(size)</span><br><span class="line">origin.<span class="title function_">writeByteArray</span>(libanon.<span class="property">base</span>.<span class="title function_">readByteArray</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x304A8</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">1</span>].<span class="title function_">toString</span>() === libanon.<span class="property">base</span>.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">            <span class="keyword">var</span> rangeDetails = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x304A8 &quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],<span class="string">&quot;base &quot;</span>,rangeDetails.<span class="property">base</span>)</span><br><span class="line">            args[<span class="number">1</span>] = origin</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x304A8] 替换成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时已经过掉了检测，并进入了首页。但是输出看到，不停在刷，maps检测明显开了线程。<br><img src="/images/DexProtector/img_16.png" alt="img_16.png"></p>
<h2 id="17-线程面收敛：定位-pthread-create-入口并“即刻返回”"><a href="#17-线程面收敛：定位-pthread-create-入口并“即刻返回”" class="headerlink" title="17. 线程面收敛：定位 pthread_create 入口并“即刻返回”"></a>17. 线程面收敛：定位 pthread_create 入口并“即刻返回”</h2><p>虽然已经完成了过掉frida检测，为了完美一点，我们再来找到线程并处理掉它。</p>
<h3 id="17-1-定位pthread-create"><a href="#17-1-定位pthread-create" class="headerlink" title="17.1 定位pthread_create"></a>17.1 定位<code>pthread_create</code></h3><p>根据 “&#x2F;proc&#x2F;self&#x2F;maps” 调用的反向引用，追到 pthread_create</p>
<p>我们使用<code>[0x40814] /proc/self/maps  lr =&gt;  0x3b66c</code>的0x3b66c，在ids中按x，一步一步向上查找。最终发现了sub_7A230，这个看起来很像是pthread_create函数：<br><img src="/images/DexProtector/img_17.png" alt="img_17.png"></p>
<p>pthread_create函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_t</span> *thread,                  <span class="comment">// [out] 新线程ID</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">// [in]  线程属性(可为NULL)</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),     <span class="comment">// [in]  线程入口函数</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *arg                           <span class="comment">// [in]  传给入口函数的参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-2-查找所有使用pthread-create的地方，并处理掉"><a href="#17-2-查找所有使用pthread-create的地方，并处理掉" class="headerlink" title="17.2 查找所有使用pthread_create的地方，并处理掉"></a>17.2 查找所有使用<code>pthread_create</code>的地方，并处理掉</h3><p>找到被创建的线程入口地址，在运行态用 Arm64Writer 写入 RET，实现就地空返回。</p>
<p>在ida中，我们通过x键，查找sub_7A230的引用，然后去把线程入口函数给处理掉。</p>
<p><img src="/images/DexProtector/img_18.png" alt="img_18.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">retFunc</span>(<span class="params">parg2</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改内存保护，使其可写</span></span><br><span class="line">    <span class="title class_">Memory</span>.<span class="title function_">protect</span>(parg2, <span class="number">4</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用 Arm64Writer 写入 &#x27;ret&#x27; 指令</span></span><br><span class="line">    <span class="keyword">var</span> writer = <span class="keyword">new</span> <span class="title class_">Arm64Writer</span>(parg2);</span><br><span class="line">    writer.<span class="title function_">putRet</span>();</span><br><span class="line">    writer.<span class="title function_">flush</span>();</span><br><span class="line">    writer.<span class="title function_">dispose</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ret &quot;</span> + parg2 + <span class="string">&quot; success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5A708</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5BE28</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D1A4</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D710</span>))</span><br></pre></td></tr></table></figure>
<p>最终结果，没有那么多线程检测一直刷了，看着比较舒服。<br><img src="/images/DexProtector/img_20.png" alt="img_20.png"><br><img src="/images/DexProtector/img_19.png" alt="img_19.png"></p>
<h1 id="结论回顾（方法-结论）"><a href="#结论回顾（方法-结论）" class="headerlink" title="结论回顾（方法 &gt; 结论）"></a>结论回顾（方法 &gt; 结论）</h1><p>入口选择决定成败：相对直接 Hook System.loadLibrary，从 __loader_android_dlopen_ext 切入能更早获得“真实装载面”的证据；</p>
<p>匿名映射段是关键战场：JNI_OnLoad → 函数指针 → 匿名段 这一跳，要求在内存态完成 dump 与“仅 text 段”的最小可用反汇编；</p>
<p>校验链路是主线：识别 xxHash&#x2F;SHA256&#x2F;HMAC 的组合与落点，用等式化替换与调用点定位做最小侵入的试探；</p>
<p>系统性缩小问题空间：从可卸载点开始做二分排除，定位到刷 maps 的线程入口，补丁而非大面积禁用，以减小误伤面与回归压力。</p>
<h2 id="限制与风险"><a href="#限制与风险" class="headerlink" title="限制与风险"></a>限制与风险</h2><p>结论对ROM&#x2F;内核&#x2F;ART 版本敏感：不同 SoC 与 API Level 下，maps 命名、权限组合、linker 细节均可能影响可见性与时序。</p>
<p>某些对抗属于“只对当下样本有效”：比如栈上&#x2F;堆上指针偏移、匿名段大小、HMAC 初始材料位置等，需在发布后持续校验与回归。</p>
<p>工具链差异：Zygisk Frida Gadget 与纯 frida-server 的可见性与时序差异</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fyrlove.github.io/2025/11/20/DexProtector/" data-id="cuiddAiqn_DXNDx7oN72aDzKe" data-title="从零开始绕过 DexProtector 加固的 Frida 检测" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2026/01/12/DexProtector2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          从零开始绕过 DexProtector 加固的 Frida 检测（二）
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">一月 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">十一月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/12/DexProtector2/">从零开始绕过 DexProtector 加固的 Frida 检测（二）</a>
          </li>
        
          <li>
            <a href="/2025/11/20/DexProtector/">从零开始绕过 DexProtector 加固的 Frida 检测</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 fyrlove<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>