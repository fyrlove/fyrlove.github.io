<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>fyrlove</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="fyrlove">
<meta property="og:url" content="https://fyrlove.github.io/index.html">
<meta property="og:site_name" content="fyrlove">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fyrlove">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="fyrlove" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fyrlove</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fyrlove.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-DexProtector2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/DexProtector2/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T03:01:41.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/12/DexProtector2/">从零开始绕过 DexProtector 加固的 Frida 检测（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="app版本更新了，如何快速进行处理？如何使用frida-server实现过检测？"><a href="#app版本更新了，如何快速进行处理？如何使用frida-server实现过检测？" class="headerlink" title="app版本更新了，如何快速进行处理？如何使用frida-server实现过检测？"></a>app版本更新了，如何快速进行处理？如何使用frida-server实现过检测？</h2><p>（本文由 id：小佳、fyrlove、roysue 共同完成）</p>
<p>这一篇可以看成是《 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-289170.htm">从零开始绕过 DexProtector 加固的 Frida 检测</a>》的续集：<br>上一版文章里，我们从 0 开始，一路跟到 DexProtector 的匿名段，把 Frida 的几类检测点（maps &#x2F; 线程监控 &#x2F; inline hook &#x2F; SHA256 校验等）一一打通，在当时的版本上实现了比较完整的一套绕过方案。</p>
<p>大家如果跟着实现了，可以发现，过掉检测后，会提示更新，这也是现实开发&#x2F;对抗的真实场景：  </p>
<blockquote>
<p><strong>App 隔三差五发个小版本更新，壳还是 DexProtector，<br> 但 so 结构、偏移、匿名段位置都变了——旧脚本直接崩，<br> 要不要从头再逆一次？</strong></p>
</blockquote>
<p>这篇文章要解决的，就是这个“日常但很致命”的问题：</p>
<blockquote>
<p><strong>当 app 小版本更新后，怎么在不推倒重来的前提下，<br> 快速把上一版已经验证过的绕过思路迁移过来？</strong></p>
</blockquote>
<p>然后，顺着这个场景，我们再往前迈一步，目前都使用了开源模块来完成过检测，这里我们后面会魔改frida-server来完成过检测：</p>
<ul>
<li>自己编译一份 <strong>固定版本的 frida 16.5.2</strong></li>
<li>在手机上用「魔改版 frida-server」直接替换原版的firda-server，<br>在 <strong>不依赖 Zygisk Frida Gadget 模块</strong> 的前提下，通过当前样本的检测</li>
</ul>
<p>所以整篇文章分成两大部分：</p>
<ol>
<li><strong>第一部分：快速修改更新后的脚本</strong>  <ul>
<li>换新样本后，如何利用 dlopen + 指针解引用 + 匿名段 dump，重新找到 DexProtector 的真实执行入口  </li>
<li>怎么用上一个版本已经踩过的“特征”（比如 <code>C8628052</code> &#x2F; <code>28108052</code> 这些常量、pthread_create 调度点、inline hook 分发函数等），<strong>批量迁移偏移</strong>，而不是重新“看一遍全图”</li>
</ul>
</li>
<li><strong>第二部分：自己编译 frida-server，并用魔改版过检测</strong>  <ul>
<li>从零安装 Ubuntu 22.04.5 虚拟机、配置共享文件夹  </li>
<li>搭建 Frida 16.5.2 的完整编译环境（NDK &#x2F; Node &#x2F; 依赖）  </li>
<li>基于开源项目 <code>ajeossida</code> 固定 Frida 版本为 16.5.2，改名为自定义的 <code>fyrrida</code>，并输出适配 Android arm64 的 server  </li>
<li>实机上用 <strong>魔改后的 frida-server</strong> 替换官方版，配合前文脚本，实测通过 DexProtector 检测</li>
</ul>
</li>
</ol>
<p>为保证结论可复现、可迁移，所有实验都在同一套环境下完成：</p>
<ul>
<li>设备：Nexus 5X  </li>
<li>系统：LineageOS 21  </li>
<li>Root &amp; 模块：Magisk 29.0.0 + LSPosed  </li>
<li>Frida：Zygisk Frida Gadget 开源模块（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a>  </li>
<li>Frida 版本：Frida Server 16.5.2  </li>
<li>魔改frida-server: fyrrida-server，基于frida16.5.2版本</li>
</ul>
<p><strong>合规声明：</strong></p>
<ul>
<li>文章仅用于安全研究与对抗评估；</li>
<li>目的是帮助甲方团队识别加固薄弱点，完善自检和回归流程；</li>
<li>不针对任何具体业务做攻击落地；</li>
<li>不提供“一键利用第三方应用”的脚本。</li>
</ul>
<hr>
<p><strong>适合谁看？</strong></p>
<ul>
<li>已经看过 &#x2F; 跑过上一篇，基本了解 DexProtector 这一版的检测策略</li>
<li>想把自己手里的 frida 从“拿来主义”升级到“可定制、可迭代”的同学</li>
</ul>
<p><strong>不适合谁？</strong></p>
<ul>
<li>想找一份“一键通杀脚本”直接上线的，这篇不提供  </li>
<li>完全不熟悉 Android &#x2F; so &#x2F; Frida 逆向环境的，建议先把基础环境、工具用法打通，再回来会更顺</li>
</ul>
<p><strong>阅读顺序建议：</strong><br>本篇所有操作，都是在上一篇文章的基础上做“版本升级迁移”。如果你还没看过第一篇，建议先看完再回来：</p>
<ul>
<li>上一篇基础篇：<br><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-289170.htm">从零开始绕过 DexProtector 加固的 Frida 检测</a></li>
</ul>
<p>下面从样本更新开始，一步步走一遍：先看旧脚本在新版本上是怎么崩的，再带着这些“已知检测点”，去新版 so 里做定位和迁移。</p>
<h1 id="第一部分：快速修改更新后的脚本（版本升级迁移）"><a href="#第一部分：快速修改更新后的脚本（版本升级迁移）" class="headerlink" title="第一部分：快速修改更新后的脚本（版本升级迁移）"></a>第一部分：快速修改更新后的脚本（版本升级迁移）</h1><p>这一部分的目标很简单：<strong>在不推倒重来的前提下，把旧脚本迁移到新版本上继续可用</strong>。<br>核心思路是：</p>
<blockquote>
<p>先定位“新的真实执行入口”，再用“老版本已知特征”去对齐“新版本偏移”。</p>
</blockquote>
<h2 id="1-更新样本与准备工作"><a href="#1-更新样本与准备工作" class="headerlink" title="1. 更新样本与准备工作"></a>1. 更新样本与准备工作</h2><h3 id="1-1-使用上一篇文章中的完整脚本进行测试"><a href="#1-1-使用上一篇文章中的完整脚本进行测试" class="headerlink" title="1.1 使用上一篇文章中的完整脚本进行测试"></a>1.1 使用上一篇文章中的完整脚本进行测试</h3><p>更新后样本：kaiyue610.apks，放在附件和文章结尾。</p>
<p>这里我没有先去看 so，而是直接沿用上一篇已经验证过的完整脚本，先执行一次，看它“死在哪里”。这一步有两个目的：</p>
<ol>
<li>快速验证：<strong>旧思路是否整体仍然成立</strong>（大概率成立，除非壳版本跨度非常大）  </li>
<li>给出一个“崩溃点”，方便后面在新 so 里对照定位</li>
</ol>
<p>端口转发：<br><img src="/images/DexProtector2/img_3.png" alt="img_3.png"></p>
<p>执行结果：<br><img src="/images/DexProtector2/img_4.png" alt="img_4.png"><br>不出意外的崩溃了。从日志可以看到是典型的“地址无效导致崩溃”。从对抗经验上，这往往意味着：</p>
<ul>
<li>整体检测链路还在</li>
<li>但<strong>关键函数 &#x2F; 检测逻辑的偏移已经变化</strong>，脚本打到了一块错误的内存区域</li>
</ul>
<p>接下来根据 610 版本的 apk，获取一下新版本的 so，并重新 dump 匿名段上的 so。</p>
<h3 id="1-2-获取新版本的专属-so（libdexprotector-so）"><a href="#1-2-获取新版本的专属-so（libdexprotector-so）" class="headerlink" title="1.2 获取新版本的专属 so（libdexprotector.so）"></a>1.2 获取新版本的专属 so（libdexprotector.so）</h3><p>第一步还是老流程：先拿到 DexProtector 自己的壳 so，也就是 <code>libdexprotector.so</code>。<br>这个so在split_config.arm64_v8a.apk里面，安装包里解压出来有，再给它解压就得到libdexprotector.so<br>把这个新版本的so用ida打开，可以看到:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span>(<span class="params">JavaVM *vm, <span class="keyword">void</span> *reserved</span>)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; </span><br><span class="line">  <span class="keyword">if</span> ( dword_B840 )</span><br><span class="line">    <span class="keyword">return</span> -dword_B840;</span><br><span class="line">  v3 = <span class="title function_">off_B848</span>(vm, <span class="number">0</span>);</span><br><span class="line">  off_B848 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="keyword">return</span> -v3;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65540</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的指针函数变成了off_B848，而上个版本这里是off_C838。</p>
<p>这一步很关键：</p>
<p>JNI_OnLoad 本身没什么花活，但它帮你给出了“下一步真正执行逻辑”的指针</p>
<p>一旦指针位置变了（off_C838 → off_B848），意味着后面所有“基于旧偏移”的脚本都要跟着调整</p>
<h3 id="1-3-dump内存段上的so"><a href="#1-3-dump内存段上的so" class="headerlink" title="1.3 dump内存段上的so"></a>1.3 dump内存段上的so</h3><p>这一步和上一篇完全一样：<br>利用 __loader_android_dlopen_ext 的 hook，把匿名段里的真正执行代码 dump 出来。</p>
<p>具体执行过程，请参考上一篇文章，这里不再赘述。<br><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-289170.htm">从零开始绕过DexProtector加固的Frida检测</a></p>
<p>这里我们只关心：新版本的匿名段 so 也已经拿到了，接下来要重新找“真实执行入口”。</p>
<h3 id="1-4-用-dlopen-指针解引用找到真实执行的函数"><a href="#1-4-用-dlopen-指针解引用找到真实执行的函数" class="headerlink" title="1.4 用 dlopen + 指针解引用找到真实执行的函数"></a>1.4 用 dlopen + 指针解引用找到真实执行的函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;__loader_android_dlopen_ext&quot;</span>)</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> pathptr = args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (pathptr !== <span class="literal">undefined</span> &amp;&amp; pathptr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> path = pathptr.<span class="title function_">readCString</span>();</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(path)</span><br><span class="line">                <span class="keyword">if</span> (path.<span class="title function_">indexOf</span>(<span class="string">&quot;libdexprotector.so&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">match</span> = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">match</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> libdexprotector = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libdexprotector.so&quot;</span>)</span><br><span class="line">                <span class="keyword">var</span> nativePointer = libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xB848</span>).<span class="title function_">readPointer</span>();</span><br><span class="line">                <span class="keyword">var</span> rangeDetails = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(nativePointer);</span><br><span class="line">                <span class="comment">// 段开始和结束</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(rangeDetails.<span class="property">base</span>)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(rangeDetails.<span class="property">base</span>.<span class="title function_">add</span>(rangeDetails.<span class="property">size</span>))</span><br><span class="line">                <span class="comment">// 开始位置</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;真实的执行函数 =&gt; &quot;</span>+nativePointer.<span class="title function_">sub</span>(rangeDetails.<span class="property">base</span>))</span><br><span class="line">                <span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">50</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hook_dlopen</span>()</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/system/framework/oat/arm64/org.<span class="property">apache</span>.<span class="property">http</span>.<span class="property">legacy</span>.<span class="property">odex</span></span><br><span class="line">/data/app/~~Z8NVPZHkUQBOvE5wdUvwlw==<span class="regexp">/com.Hyatt.hyt-h-4z3JSgsyZQX5dyLoDPUg==/</span>oat/arm64/base.<span class="property">odex</span></span><br><span class="line">/data/app/~~Z8NVPZHkUQBOvE5wdUvwlw==<span class="regexp">/com.Hyatt.hyt-h-4z3JSgsyZQX5dyLoDPUg==/</span>split_config.<span class="property">arm64_v8a</span>.<span class="property">apk</span>!<span class="regexp">/lib/</span>arm64-v8a/libalice.<span class="property">so</span></span><br><span class="line">/data/app/~~Z8NVPZHkUQBOvE5wdUvwlw==<span class="regexp">/com.Hyatt.hyt-h-4z3JSgsyZQX5dyLoDPUg==/</span>split_config.<span class="property">arm64_v8a</span>.<span class="property">apk</span>!<span class="regexp">/lib/</span>arm64-v8a/libdpboot.<span class="property">so</span></span><br><span class="line">/data/app/~~Z8NVPZHkUQBOvE5wdUvwlw==<span class="regexp">/com.Hyatt.hyt-h-4z3JSgsyZQX5dyLoDPUg==/</span>split_config.<span class="property">arm64_v8a</span>.<span class="property">apk</span>!<span class="regexp">/lib/</span>arm64-v8a/libdexprotector.<span class="property">so</span></span><br><span class="line"><span class="number">0x75ffc04000</span></span><br><span class="line"><span class="number">0x75ffc80000</span></span><br><span class="line">真实的执行函数 =&gt; <span class="number">0x4ec38</span></span><br></pre></td></tr></table></figure>
<p>这里有几个信息点：</p>
<p>libdexprotector.so 还是正常通过 __loader_android_dlopen_ext 加载</p>
<p>off_B848 指向的地址，仍然落在一个匿名段范围内（0x75ffc04000 ~ 0x75ffc80000）</p>
<p>真正执行逻辑的入口偏移变成了 0x4ec38</p>
<p>小结一下这一节：</p>
<ul>
<li>旧脚本崩溃，让我们确认“检测逻辑还在”；</li>
<li>新指针 off_B848 + 匿名段 dump，让我们拿到了新版本的真正起点（0x4ec38）。</li>
<li>下面所有迁移工作，都是围绕这个入口展开的。</li>
</ul>
<h3 id="1-5-使用ida对dump的so进行修复"><a href="#1-5-使用ida对dump的so进行修复" class="headerlink" title="1.5 使用ida对dump的so进行修复"></a>1.5 使用ida对dump的so进行修复</h3><p>修复方法和上一篇一样：把 dump 出来的匿名段 so，按 text 段对齐、修复重定位，尽量恢复出一个“可读”的 IDA 工程。</p>
<p>这里是我已经修复之后的，修复手法，请参考上一篇文章。<br><img src="/images/DexProtector2/img_5.png" alt="img_5.png"></p>
<p>到这里，准备工作就完成了。</p>
<p>剩下的，就是围绕新的入口偏移 0x4ec38，去重新定位各类检测点：pthread_create、inline hook 分发、SHA-256 校验、maps 检测等。</p>
<h2 id="02-思考，针对更新如何进行处理"><a href="#02-思考，针对更新如何进行处理" class="headerlink" title="02.思考，针对更新如何进行处理"></a>02.思考，针对更新如何进行处理</h2><h3 id="2-1-根据上次完成的脚本，来进行思考，分析检测特征有哪些"><a href="#2-1-根据上次完成的脚本，来进行思考，分析检测特征有哪些" class="headerlink" title="2.1 根据上次完成的脚本，来进行思考，分析检测特征有哪些"></a>2.1 根据上次完成的脚本，来进行思考，分析检测特征有哪些</h3><ul>
<li>特征一、线程创建，线程检测（phtread_create是第一个特征）<br>这一块是最典型的“监控线程 + 检测循环”逻辑。上一版里，我们直接对几个关键调用点做了 ret：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5A708</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5BE28</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D1A4</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D710</span>))</span><br></pre></td></tr></table></figure>
<p>这里本质上是在阻断监控线程的创建，让它根本跑不起来。</p>
<ul>
<li>特征二、inline hook<br>这里有两类，一类是“看 LR 决定走哪段逻辑”的分发函数：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash_crc = &#123;</span><br><span class="line">    <span class="string">&quot;0x4f5a4&quot;</span> : <span class="string">&quot;0x8A810&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x4f6cc&quot;</span> : <span class="string">&quot;0x8A810&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x5c494&quot;</span> : <span class="string">&quot;0x8AB20&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x161E8</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>,<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>))</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()])&#123;</span><br><span class="line">            ret.<span class="title function_">replace</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()]).<span class="title function_">readU64</span>())</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 leave&quot;</span>,ret)</span><br><span class="line">        &#125;                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>另一类是“利用指针替换”的方式，把原来的校验函数指向我们想要的地址：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x304A8</span>), &#123;</span><br><span class="line">                    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">                           <span class="comment">//这里是sha256</span></span><br><span class="line">                        <span class="keyword">if</span> (args[<span class="number">1</span>].<span class="title function_">toString</span>() === libanon.<span class="property">base</span>.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">                            <span class="keyword">var</span> rangeDetails = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(args[<span class="number">0</span>]);</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x304A8 &quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],<span class="string">&quot;base &quot;</span>,rangeDetails.<span class="property">base</span>)</span><br><span class="line">                            args[<span class="number">1</span>] = origin</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x304A8] 替换成功&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>
<p>这两类逻辑，有一个共同点：</p>
<blockquote>
<p>它们本身不承担“检测计算”，而是“调度 &#x2F; 分发 &#x2F; 接线”，属于非常稳定的结构。<br>版本更新时，里面被调用的具体函数地址会变，但“整体骨架 + 控制方式”大概率不变。</p>
</blockquote>
<ul>
<li>特征三、maps检测<br>通过上一篇文章的分析，可以知道这个函数返回的结果是790</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook_maps</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x61974</span>),&#123; </span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0x61974 =&gt; &quot;</span>,retval.<span class="title function_">toInt32</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">        retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在ida中定位到0x61974，查看790，按tab，查看汇编，这个W8, #0x316，基本是不会变化的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM:0000000000061C84                 MOV             W8, #0x316</span><br></pre></td></tr></table></figure>
<p>也就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C8628052</span><br></pre></td></tr></table></figure>
<p><img src="/images/DexProtector2/img_1.png" alt="img_1.png"><br><img src="/images/DexProtector2/img.png" alt="img.png"></p>
<p>所以，总体上，我们需要处理的检测有这几类：</p>
<ol>
<li>线程创建 &#x2F; 监控线程（pthread_create）</li>
<li>inline hook 分发函数（通过 LR 决定后续逻辑）</li>
<li>SHA-256 &#x2F; CRC 等校验逻辑（通过指针参数 &#x2F; 填充来替换）</li>
<li>maps 检测（通过固定常量快速定位）</li>
</ol>
<p>接下来就是实战部分：怎么把这些“共性特征”迁移到新版本上。</p>
<h2 id="03-实际操作：基于“入口-特征”的偏移迁移"><a href="#03-实际操作：基于“入口-特征”的偏移迁移" class="headerlink" title="03.实际操作：基于“入口 + 特征”的偏移迁移"></a>03.实际操作：基于“入口 + 特征”的偏移迁移</h2><p>app小版本更新，检测点很大概率是不会发生变化的。所以按思路，拿到新dump下来的so之后，顺序进行分析。<br>上面已经拿到真实的执行函数 &#x3D;&gt; 0x4ec38</p>
<h3 id="3-1-顺序查找，定位新的inline-hook，并修改代码"><a href="#3-1-顺序查找，定位新的inline-hook，并修改代码" class="headerlink" title="3.1 顺序查找，定位新的inline hook，并修改代码"></a>3.1 顺序查找，定位新的inline hook，并修改代码</h3><p>在ida中打开新的libanon.so，按G，跳转到0x4ec38。<br><img src="/images/DexProtector2/img_6.png" alt="img_6.png"><br>从这里开始，顺藤摸瓜往下点：点击第一个函数sub_4ED54，进去后，结果如下：<br><img src="/images/DexProtector2/img_7.png" alt="img_7.png"><br>按之前文章分析，可以知道，新的so中，最关键的函数就是sub_4F508了。</p>
<p>进入sub_4F508了之后，顺序进行分析，很快就能找到做inline hook的地方，sub_165F0：<br><img src="/images/DexProtector2/img_8.png" alt="img_8.png"><br> 引用查找sub_165F0，找到需要定位的lr，完成后的代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash_crc = &#123;</span><br><span class="line">    <span class="string">&quot;0x4f858&quot;</span>: <span class="string">&quot;0x8AE20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x4f980&quot;</span>: <span class="string">&quot;0x8AE20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x53c58&quot;</span>: <span class="string">&quot;0x8AF00&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x5c8f0&quot;</span>: <span class="string">&quot;0x8B140&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x165F0</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0x165F0 enter&quot;</span>,<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>))</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()])&#123;</span><br><span class="line">            ret.<span class="title function_">replace</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()]).<span class="title function_">readU64</span>())</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0x165F0 leave&quot;</span>,ret)</span><br><span class="line">        &#125;                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到这里，第一步“顺序查找 + inline hook 迁移”就完成了：</p>
<ul>
<li>老版本中的 sub_161E8 → 新版本中的 sub_165F0</li>
<li>LR 与目标偏移的映射关系重新整理成了新版的 hash_crc</li>
</ul>
<h3 id="3-2-快速定位sha256的位置（特征字节法）"><a href="#3-2-快速定位sha256的位置（特征字节法）" class="headerlink" title="3.2 快速定位sha256的位置（特征字节法）"></a>3.2 快速定位sha256的位置（特征字节法）</h3><p>使用010editor，ctrl+f，进行搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6560045e5040115e</span><br></pre></td></tr></table></figure>
<p>搜索结果，右键复制地址：<br><img src="/images/DexProtector2/img_9.png" alt="img_9.png"><br>到ida中跳转地址，直接就定位到了sha256的函数，sub_308B0：<br><img src="/images/DexProtector2/img_10.png" alt="img_10.png"></p>
<p>修改之后的代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x308B0</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">1</span>].<span class="title function_">toString</span>() === libanon.<span class="property">base</span>.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">            <span class="keyword">var</span> rangeDetails = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x308B0 &quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],<span class="string">&quot;base &quot;</span>,rangeDetails.<span class="property">base</span>)</span><br><span class="line">            args[<span class="number">1</span>] = origin</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x308B0] 替换成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行一下脚本，拿到地址是0x7a8b0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x165F0 enter 0x4f858</span><br><span class="line">0x165F0 leave 0x832d39a094055b4f</span><br><span class="line">onEnter  0x308B0  0x7fc00018c0 0x79ee96c000 0x7a8b0 base  0x7fbf80b000</span><br><span class="line">[0x308B0] 替换成功</span><br></pre></td></tr></table></figure>
<p>使用0x7a8b0，更新脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> origin</span><br><span class="line"><span class="keyword">var</span> size=<span class="number">0x7a8b0</span></span><br></pre></td></tr></table></figure>
<p>这一步完成后，新版的 SHA-256 校验逻辑也已经被“接管”，后续就不会再因为 hash 校验失败而崩溃。</p>
<h3 id="3-3-使用特征常量快速定位新的-maps-检测"><a href="#3-3-使用特征常量快速定位新的-maps-检测" class="headerlink" title="3.3 使用特征常量快速定位新的 maps 检测"></a>3.3 使用特征常量快速定位新的 maps 检测</h3><p>使用之前的C8628052，在010editor中进行搜索：<br><img src="/images/DexProtector2/img_11.png" alt="img_11.png"><br>直接就搜索到了，右键复制地址，然后去ida中跳转地址，直接就定位上了，sub_61FBC：<br><img src="/images/DexProtector2/img_12.png" alt="img_12.png"></p>
<p>修改之后的代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook_maps</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x61FBC</span>),&#123; </span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0x61FBC =&gt; &quot;</span>,retval.<span class="title function_">toInt32</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">        retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过这一步，可以验证两个结论：</p>
<ul>
<li>DexProtector 的 maps 检测逻辑整体没有被删除，只是偏移发生了变化</li>
<li>“固定返回 0x316 &#x2F; 790” 这种做法，在多版本之间具有很强的可迁移性，非常适合拿来做锚点</li>
</ul>
<h3 id="3-4-接下来是最后一个，pthread-create监控线程"><a href="#3-4-接下来是最后一个，pthread-create监控线程" class="headerlink" title="3.4 接下来是最后一个，pthread_create监控线程"></a>3.4 接下来是最后一个，pthread_create监控线程</h3><p>在010editor中搜索：28108052<br><img src="/images/DexProtector2/img_13.png" alt="img_13.png"><br>复制地址，到ida跳转地址：<br><img src="/images/DexProtector2/img_14.png" alt="img_14.png"><br>定位到了sub_5AB20，按x查找引用：<br><img src="/images/DexProtector2/img_15.png" alt="img_15.png"><br>跳转后，找到了pthread_create:<br><img src="/images/DexProtector2/img_16.png" alt="img_16.png"><br>基本上可以确定这个sub_7A860这个函数就是pthread_create了，找它全部调用的地方全部ret掉。</p>
<p>在sub_7A860按x，查找所有引用：<br><img src="/images/DexProtector2/img_17.png" alt="img_17.png"><br>然后修改之前的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5AB20</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5C280</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D5FC</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5DB68</span>))</span><br></pre></td></tr></table></figure>
<p>到这里，新版本的“监控线程创建”也已经全部封死。</p>
<h2 id="所有检测点的新版本修改完毕"><a href="#所有检测点的新版本修改完毕" class="headerlink" title="所有检测点的新版本修改完毕"></a>所有检测点的新版本修改完毕</h2><p>执行新的代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -H 127.0.0.1:9999 -F -l hook_dexprotectB848.js</span><br></pre></td></tr></table></figure>
<p>执行结果，成功过掉了610版本的检测：<br><img src="/images/DexProtector2/img_18.png" alt="img_18.png"><br><img src="/images/DexProtector2/img_19.png" alt="img_19.png"></p>
<h2 id="4-把这一套变成你的“版本升级-SOP”"><a href="#4-把这一套变成你的“版本升级-SOP”" class="headerlink" title="4. 把这一套变成你的“版本升级 SOP”"></a>4. 把这一套变成你的“版本升级 SOP”</h2><p>这一部分，把版本升级后，如果快速处理脚本更新做了一个详细的拆解。可以总结成一套反复可用的流程。<br>步骤如下：</p>
<ol>
<li>先跑一次旧脚本，看看”死在哪儿”</li>
<li>拿到新版本崩溃的so，并定位新的入口</li>
<li>dump新的匿名段so，锁定新的真实入口</li>
<li>根据新的入口在 IDA 里顺序查找，替换 Frida 脚本里的偏移</li>
<li>用“特征常量 + 010 Editor”快速锚定新检测点</li>
</ol>
<p>以上就完成了版本更新后，快速定位修改脚本并过检测的目的。下面，开始详细分析字符串，还原分析过程。</p>
<h3 id="5-通过打印日志分析字符串"><a href="#5-通过打印日志分析字符串" class="headerlink" title="5. 通过打印日志分析字符串"></a>5. 通过打印日志分析字符串</h3><p>这一节算是一个“预告性质”的内容：<br>当前样本在绕过后，继续打印了一些字符串日志，可以看出 DexProtector 在做更多维度的环境检测。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x40A68</span>] <span class="title class_">XposedBridge</span>  lr =&gt;  <span class="number">0x65e28</span></span><br><span class="line">[<span class="number">0x40A68</span>] xposed/dummy/<span class="title class_">XResourcesSuperClass</span>  lr =&gt;  <span class="number">0x65a54</span></span><br><span class="line">[<span class="number">0x40A68</span>] /proc/self/status  lr =&gt;  <span class="number">0x5a820</span></span><br><span class="line">[<span class="number">0x40A68</span>] dalvik/system/<span class="title class_">VMDebug</span>  lr =&gt;  <span class="number">0x5d770</span></span><br><span class="line">[<span class="number">0x40A68</span>] isDebuggerConnected  lr =&gt;  <span class="number">0x5d7b8</span></span><br><span class="line">[<span class="number">0x40A68</span>] ()Z  lr =&gt;  <span class="number">0x5d7d4</span></span><br><span class="line">[<span class="number">0x40A68</span>] /proc/self/maps  lr =&gt;  <span class="number">0x3b68c</span></span><br><span class="line">[<span class="number">0x40A68</span>] libart.<span class="property">so</span>  lr =&gt;  <span class="number">0x5d8c4</span></span><br><span class="line">[<span class="number">0x40A68</span>] libriru  lr =&gt;  <span class="number">0x61648</span></span><br><span class="line">[<span class="number">0x40A68</span>] .<span class="property">magisk</span>  lr =&gt;  <span class="number">0x61660</span></span><br><span class="line">[<span class="number">0x40A68</span>] zygisk  lr =&gt;  <span class="number">0x616b8</span></span><br></pre></td></tr></table></figure>
<p>在输出中可以看到有zygisk字符串，选zygisk，在ida中去查看一下，<br><img src="/images/DexProtector2/img_20.png" alt="img_20.png"><br>一般来说，有解密就有比较。分别查看sub_12374和sub_120B0之后，可以知道sub_120B0就是用来做比较的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_120B0</span><span class="params">(<span class="type">unsigned</span> __int8 *a1, <span class="type">unsigned</span> __int8 *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// w9</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// w8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = *a1;</span><br><span class="line">    v3 = v2 - *a2;</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++a2;</span><br><span class="line">    ++a1;</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以hook看一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x120B0</span>),&#123; </span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0x120B0 =&gt; &quot;</span>,<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>,args[<span class="number">0</span>].<span class="title function_">readCString</span>(),args[<span class="number">1</span>].<span class="title function_">readCString</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果，多输出了很多的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> blog.<span class="property">so</span> blog.<span class="property">so</span></span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> log.<span class="property">so</span> log.<span class="property">so</span></span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> og.<span class="property">so</span> og.<span class="property">so</span></span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> g.<span class="property">so</span> g.<span class="property">so</span></span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> .<span class="property">so</span> .<span class="property">so</span></span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> so so</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> o o</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span>  </span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0x3abfc</span> __android_log_btwrite __android_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> _android_log_btwrite _android_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> android_log_btwrite android_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> ndroid_log_btwrite ndroid_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> droid_log_btwrite droid_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> roid_log_btwrite roid_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> oid_log_btwrite oid_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> id_log_btwrite id_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> d_log_btwrite d_log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> _log_btwrite _log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> log_btwrite log_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> og_btwrite og_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> g_btwrite g_btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> _btwrite _btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> btwrite btwrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> twrite twrite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> write write</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> rite rite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> ite ite</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> te te</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span> e e</span><br><span class="line"><span class="number">0x120B0</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0xa6f9560c</span>  </span><br></pre></td></tr></table></figure>

<p>hook sub_12374</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x12374</span>),&#123; </span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0x12374 =&gt; &quot;</span>,<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>,args[<span class="number">0</span>].<span class="title function_">readCString</span>(),args[<span class="number">1</span>].<span class="title function_">readCString</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果，又多了很多的字符串输出：<br>这里只截取了很小的一部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x12374</span> =&gt;   <span class="function"><span class="params">lr</span> =&gt;</span>  <span class="number">0x65800</span> <span class="number">451</span> <span class="number">447</span> <span class="number">259</span>:<span class="number">9</span> / <span class="regexp">/ ro,relatime master:1 - ext4 /</span>dev/block/mmcblk0p41 ro,seclabel,inode_readahead_blks=<span class="number">8</span></span><br><span class="line"><span class="number">492</span> <span class="number">451</span> <span class="number">0</span>:<span class="number">12</span> / /dev rw,nosuid,relatime <span class="attr">master</span>:<span class="number">2</span> - tmpfs tmpfs rw,seclabel,size=1428040k,nr_inodes=<span class="number">357010</span>,mode=<span class="number">755</span></span><br><span class="line"><span class="number">493</span> <span class="number">492</span> <span class="number">0</span>:<span class="number">9</span> / <span class="regexp">/dev/</span>pts rw,relatime <span class="attr">master</span>:<span class="number">3</span> - devpts devpts rw,seclabel,mode=<span class="number">600</span></span><br><span class="line"><span class="number">494</span> <span class="number">492</span> <span class="number">0</span>:<span class="number">20</span> / <span class="regexp">/dev/</span>cpuctl rw,nosuid,nodev,noexec,relatime <span class="attr">master</span>:<span class="number">17</span> - cgroup none rw,cpu</span><br><span class="line"><span class="number">495</span> <span class="number">492</span> <span class="number">0</span>:<span class="number">21</span> / <span class="regexp">/dev/</span>cpuset rw,nosuid,nodev,noexec,relatime <span class="attr">master</span>:<span class="number">18</span> - cgroup none rw,cpuset,noprefix,release_agent=<span class="regexp">/sbin/</span>cpuset_release_agent</span><br><span class="line"><span class="number">496</span> <span class="number">492</span> <span class="number">0</span>:<span class="number">22</span> / <span class="regexp">/dev/m</span>emcg rw,nosuid,nodev,noexec,relatime <span class="attr">master</span>:<span class="number">19</span> - cgroup none rw,memory</span><br><span class="line"><span class="number">497</span> <span class="number">492</span> <span class="number">0</span>:<span class="number">26</span> / <span class="regexp">/dev/u</span>sb-ffs/adb rw,noatime <span class="attr">master</span>:<span class="number">32</span> - functionfs adb rw</span><br><span class="line"><span class="number">498</span> <span class="number">451</span> <span class="number">0</span>:<span class="number">3</span> / /proc rw,relatime <span class="attr">master</span>:<span class="number">4</span> - proc proc rw,gid=<span class="number">3009</span>,hidepid=<span class="number">2</span></span><br><span class="line"><span class="number">499</span> <span class="number">451</span> <span class="number">0</span>:<span class="number">14</span> / /sys rw,relatime <span class="attr">master</span>:<span class="number">5</span> - sysfs sysfs rw,seclabel</span><br><span class="line"><span class="number">500</span> <span class="number">499</span> <span class="number">0</span>:<span class="number">11</span> / <span class="regexp">/sys/</span>fs/selinux rw,relatime <span class="attr">master</span>:<span class="number">6</span> - selinuxfs selinuxfs rw</span><br><span class="line"><span class="number">538</span> <span class="number">499</span> <span class="number">0</span>:<span class="number">5</span> / <span class="regexp">/sys/</span>kernel/debug rw,relatime <span class="attr">master</span>:<span class="number">24</span> - debugfs debugfs rw,seclabel</span><br><span class="line"><span class="number">539</span> <span class="number">499</span> <span class="number">0</span>:<span class="number">24</span> / <span class="regexp">/sys/</span>fs/fuse/connections rw,relatime <span class="attr">master</span>:<span class="number">26</span> - fusectl none rw</span><br><span class="line"><span class="number">540</span> <span class="number">499</span> <span class="number">0</span>:<span class="number">25</span> / <span class="regexp">/sys/</span>fs/pstore rw,nosuid,nodev,noexec,relatime <span class="attr">master</span>:<span class="number">27</span> - pstore pstore rw,seclabel</span><br><span class="line"><span class="number">541</span> <span class="number">451</span> <span class="number">0</span>:<span class="number">15</span> / /mnt rw,nosuid,nodev,noexec,relatime <span class="attr">master</span>:<span class="number">7</span> - tmpfs tmpfs rw,seclabel,size=1428040k,nr_inodes=<span class="number">357010</span>,mode=<span class="number">755</span>,gid=<span class="number">1000</span></span><br><span class="line"><span class="number">542</span> <span class="number">541</span> <span class="number">0</span>:<span class="number">15</span> /user /mnt/installer rw,nosuid,nodev,noexec,relatime <span class="attr">master</span>:<span class="number">14</span> - tmpfs tmpfs rw,seclabel,size=1428040k,nr_inodes=<span class="number">357010</span>,mode=<span class="number">755</span>,gid=<span class="number">1000</span></span><br><span class="line"><span class="number">543</span> <span class="number">542</span> <span class="number">0</span>:<span class="number">86</span> / <span class="regexp">/mnt/i</span>nstaller/<span class="number">0</span>/emulated rw,nosuid,nodev,noexec,noatime <span class="attr">master</span>:<span class="number">260</span> - fuse /dev/fuse rw,lazytime,user_id=<span class="number">0</span>,group_id=<span class="number">0</span>,allow_other</span><br><span class="line"><span class="number">544</span> <span class="number">543</span> <span class="number">0</span>:<span class="number">85</span> /<span class="number">0</span>/<span class="title class_">Android</span>/data /mnt/installer/<span class="number">0</span>/emulated/<span class="number">0</span>/<span class="title class_">Android</span>/data rw,nosuid,nodev,noexec,noatime <span class="attr">master</span>:<span class="number">263</span> - sdcardfs /data/media rw,fsuid=<span class="number">1023</span>,fsgid=<span class="number">1023</span>,gid=<span class="number">1015</span>,multiuser,mask=<span class="number">6</span>,derive_gid,default_normal,unshared_obb</span><br><span class="line"><span class="number">545</span> <span class="number">543</span> <span class="number">0</span>:<span class="number">85</span> /<span class="number">0</span>/<span class="title class_">Android</span>/data /mnt/installer/<span class="number">0</span>/emulated/<span class="number">0</span>/<span class="title class_">Android</span>/data rw,nosuid,nodev,noexec,noatime <span class="attr">master</span>:<span class="number">263</span> - sdcardfs /data/media rw,fsuid=<span class="number">1023</span>,fsgid=<span class="number">1023</span>,gid=<span class="number">1015</span>,multiuser,mask=<span class="number">6</span>,derive_gid,default_normal,unshared_obb</span><br><span class="line"><span class="number">546</span> <span class="number">543</span> <span class="number">0</span>:<span class="number">85</span> /<span class="number">0</span>/<span class="title class_">Android</span>/obb /mnt/installer/<span class="number">0</span>/emulated/<span class="number">0</span>/<span class="title class_">Android</span>/obb rw,nosuid,nodev,noexec,noatime <span class="attr">master</span>:<span class="number">251</span> - sdcardfs /data/media rw,fsuid=<span class="number">1023</span>,fsgid=<span class="number">1023</span>,gid=<span class="number">1015</span>,multiuser,mask=<span class="number">6</span>,derive_gid,default_normal,unshared_obb</span><br><span class="line"><span class="number">547</span> <span class="number">543</span> <span class="number">0</span>:<span class="number">85</span> /<span class="number">0</span>/<span class="title class_">Android</span>/obb /mnt/installer/<span class="number">0</span>/emulated/<span class="number">0</span>/<span class="title class_">Android</span>/obb rw,nosuid,nodev,noexec,noatime <span class="attr">master</span>:<span class="number">251</span> - sdcardfs /data/media rw,fsuid=<span class="number">1023</span>,fsgid=<span class="number">1023</span>,gid=<span class="number">9997</span>,multiuser,mask=<span class="number">7</span>,derive_gid,default_normal,unshared_obb</span><br></pre></td></tr></table></figure>
<p>关于字符串更多的分析，以后在深入分析。不是今天的目的。</p>
<p>接下来，进入第二部分：从环境本身下手，魔改一个属于自己的 frida-server</p>
<h1 id="第二部分：使用编译-frida-server-过检测（自定义-fyrrida）"><a href="#第二部分：使用编译-frida-server-过检测（自定义-fyrrida）" class="headerlink" title="第二部分：使用编译 frida-server 过检测（自定义 fyrrida）"></a>第二部分：使用编译 frida-server 过检测（自定义 fyrrida）</h1><h2 id="使用魔改后的frida-server，过掉检测，告别Zygisk-Frida-Gadget-开源模块"><a href="#使用魔改后的frida-server，过掉检测，告别Zygisk-Frida-Gadget-开源模块" class="headerlink" title="使用魔改后的frida-server，过掉检测，告别Zygisk Frida Gadget 开源模块"></a>使用魔改后的frida-server，过掉检测，告别Zygisk Frida Gadget 开源模块</h2><p>下面的过程分为两步：</p>
<p>在 Ubuntu 22.04.5 上，从 0 到 1 编译官方 Frida 16.5.2</p>
<p>在此基础上，用 ajeossida 进行魔改，生成自己的 fyrrida server</p>
<h2 id="在-Ubuntu-22-04-5-上编译-Frida-16-5-2：从系统安装到环境配置全流程"><a href="#在-Ubuntu-22-04-5-上编译-Frida-16-5-2：从系统安装到环境配置全流程" class="headerlink" title="在 Ubuntu 22.04.5 上编译 Frida 16.5.2：从系统安装到环境配置全流程"></a>在 Ubuntu 22.04.5 上编译 Frida 16.5.2：从系统安装到环境配置全流程</h2><blockquote>
<p>目标：  </p>
<ul>
<li>使用 <code>ubuntu-22.04.5-desktop-amd64.iso</code> 安装一台全新的 Ubuntu 桌面系统  </li>
<li>在虚拟机中配置「共享文件夹」方便和宿主机互传文件  </li>
<li>搭建 <strong>Frida 16.5.2</strong> 所需的构建环境，并从源码编译</li>
</ul>
</blockquote>
<blockquote>
<p>说明：  </p>
<ul>
<li>以 <strong>Ubuntu 22.04.5 Desktop 64-bit</strong> 为例  </li>
<li>虚拟机平台 <strong>VMware</strong></li>
</ul>
</blockquote>
<hr>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-下载-Ubuntu-22-04-5-ISO"><a href="#1-下载-Ubuntu-22-04-5-ISO" class="headerlink" title="1. 下载 Ubuntu 22.04.5 ISO"></a>1. 下载 Ubuntu 22.04.5 ISO</h3><ul>
<li>正常安装Ubuntu，阿里云ubuntu-22.04.5-desktop-amd64.iso<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.aliyun.com/ubuntu-releases/22.04.4</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-新建虚拟机"><a href="#2-新建虚拟机" class="headerlink" title="2. 新建虚拟机"></a>2. 新建虚拟机</h3><ul>
<li><p>这里以 VMware 为例：</p>
</li>
<li><p>新建虚拟机 → 选择「稍后安装操作系统」或直接选择 ISO。</p>
</li>
<li><p>客户机操作系统选择：</p>
<p>  类型：Linux</p>
<p>  版本：Ubuntu 64-bit</p>
</li>
<li><p>分配资源（推荐）：</p>
<p>  CPU：2 核以上</p>
<p>  内存：4 GB 起步，建议 8 GB</p>
<p>  磁盘：60 GB 或以上，单文件虚拟磁盘</p>
</li>
<li><p>在虚拟机设置中，将 ubuntu-22.04.5-desktop-amd64.iso 挂载为 CD&#x2F;DVD。</p>
</li>
</ul>
<h3 id="3-搭建Ubuntu开发环境"><a href="#3-搭建Ubuntu开发环境" class="headerlink" title="3. 搭建Ubuntu开发环境"></a>3. 搭建Ubuntu开发环境</h3><p>创建共享文件夹</p>
<p>右键虚拟机 -&gt; 设置 -&gt; 共享文件夹启动 -&gt; 选择文件夹确认</p>
<p><img src="/images/DexProtector2/img_23.png" alt="img_23.png"></p>
<p>右键打开终端执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other -o uid=0 -o gid=0 -o umask=022</span><br></pre></td></tr></table></figure>

<p>如果没有&#x2F;mnt&#x2F;hgfs创建一个目录，这个时候不是永久的</p>
<p>修改fstab文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /etc/fstab</span><br></pre></td></tr></table></figure>

<p>最后增加一行(如果使用vim要sudo vim)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,uid=0,gid=0,umask=022 0 0</span><br></pre></td></tr></table></figure>

<p>ln把frida文件夹创建一个链接放到桌面上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /mnt/hgfs/gx ~/Desktop/</span><br></pre></td></tr></table></figure>

<p>这个时候桌面出现frida，它在右下角</p>
<p><img src="/images/DexProtector2/img_24.png" alt="img_24.png"></p>
<p>更新包(这些打开终端直接执行就可以，简单)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>安装gcc编译器相关的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure>

<p>安装git，vim</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install vim</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>

<p>安装nvm(用来安装node的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash</span><br></pre></td></tr></table></figure>

<p>查看node安装版本(node 20.10最好)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 20.10.0</span><br></pre></td></tr></table></figure>


<p>安装配置ndk开发环境</p>
<p>搜索ndk下载，下载ndk25版本的，可以window下载放到共享文件夹里面去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://dl.google.com/android/repository/android-ndk-r25c-linux.zip</span><br></pre></td></tr></table></figure>

<p>创建value目录在Home里面</p>
<p><img src="/images/DexProtector2/img_25.png" alt="img_25.png"></p>
<p>创建好了之后解压在home里面，设置<del>&#x2F;.bashrc环境变量</del>代指home</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">下面这两行加到文件最后的位置去，这两个是环境变量，其中PATH就是我们执行bin相关的位置</span><br><span class="line">export ANDROID_NDK_ROOT=~/value/android-ndk-r25c</span><br><span class="line">export PATH=$PATH:$ANDROID_NDK_ROOT</span><br></pre></td></tr></table></figure>

<p>ANDROID_NDK_ROOT是frida需要的</p>
<p>然后执行更新环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="4-编译官方-frida-core（为后续魔改打基础）"><a href="#4-编译官方-frida-core（为后续魔改打基础）" class="headerlink" title="4. 编译官方 frida-core（为后续魔改打基础）"></a>4. 编译官方 frida-core（为后续魔改打基础）</h3><p>这一小节的目标不是“立刻产出可躲检测版本”，而是：</p>
<p>先保证你在本机能 从源码 → 原版 frida-server 的整个过程跑通，<br>后面再在这个基础上去做魔改，会轻松很多。</p>
<p>在文件夹里面下载frida-core源码，我只需要frida-server，只拉取frida-core就行了，不用拉取整个frida</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/frida/frida-core.git</span><br></pre></td></tr></table></figure>

<p>cd进去frida-core文件夹，执行加载子模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<p>配置（我这里使用android-arm64，是因为我的手机是arm64,）<br>可以选择：[“android-arm64”, “android-arm”, “android-x86_64”, “android-x86”]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=android-arm64</span><br></pre></td></tr></table></figure>

<p>这样就算是成功了：<br><img src="/images/DexProtector2/img_27.png" alt="img_27.png"></p>
<p>使用 make 编译，注意arm64的个数是285</p>
<p><img src="/images/DexProtector2/img_26.png" alt="img_26.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>后面要魔改frida，这里必须要先编译一次。</p>
<p>重新编译直接把build全部删掉就可以</p>
<p>如果后面编译不了，删除deps目录，删除build目录</p>
<h2 id="二-使用-ajeossida-魔改生成固定版本的-frida（fyrrida）"><a href="#二-使用-ajeossida-魔改生成固定版本的-frida（fyrrida）" class="headerlink" title="二. 使用 ajeossida 魔改生成固定版本的 frida（fyrrida）"></a>二. 使用 ajeossida 魔改生成固定版本的 frida（fyrrida）</h2><p><a target="_blank" rel="noopener" href="https://github.com/hackcatml/ajeossida">使用了开源库ajeossida进行编译</a></p>
<p>不想要自己编译的，可以在开源库的release里面去下载成品，不用关心后面的内容。</p>
<h3 id="1-在-Ubuntu-22-04-上打造「fyrrida」——基于-frida-16-5-2-的自定义隐藏版本"><a href="#1-在-Ubuntu-22-04-上打造「fyrrida」——基于-frida-16-5-2-的自定义隐藏版本" class="headerlink" title="1. 在 Ubuntu 22.04 上打造「fyrrida」——基于 frida 16.5.2 的自定义隐藏版本"></a>1. 在 Ubuntu 22.04 上打造「fyrrida」——基于 frida 16.5.2 的自定义隐藏版本</h3><p>前面我们已经在 Ubuntu 22.04.5 上完成了 Frida 16.5.2 的基础编译环境。<br>在此基础上，使用开源库魔改编译一个自己的frida-server：</p>
<ul>
<li>基于 Frida 16.5.2  </li>
<li>使用第三方脚本（如 <code>hackcatml/ajeossida</code>）  </li>
<li><strong>自动改名 &amp; 去掉常见 Frida 特征</strong>  </li>
<li>编译出自己的「定制版 Frida」，这里命名为：<strong>fyrrida</strong></li>
</ul>
<blockquote>
<p>⚠️ 说明  </p>
<ul>
<li>本节重点在于“改名 + 去特征 + 固定版本 16.5.2”的流程思路。  </li>
<li>代码片段可根据本地真实路径微调。  </li>
<li>本节默认你已经完成前文「搭建 Frida 16.5.2 的编译环境」。</li>
</ul>
</blockquote>
<hr>
<h3 id="2-整体思路可以概括为三步："><a href="#2-整体思路可以概括为三步：" class="headerlink" title="2. 整体思路可以概括为三步："></a>2. 整体思路可以概括为三步：</h3><ol>
<li><p><strong>准备构建脚本仓库</strong><br>使用 <code>ajeossida</code> 项目，对 Frida 做一层“包装”：统一改名、注释掉一些经典 hook 点、修改线程名等。</p>
</li>
<li><p><strong>强制使用 Frida 16.5.2 源码 + 自定义名字 <code>fyrrida</code></strong>  </p>
<ul>
<li>修改脚本的 <code>git_clone_repo()</code>：clone 时直接 checkout 16.5.2 tag。  </li>
<li>把默认的 <code>CUSTOM_NAME = &quot;ajeossida&quot;</code> 改为 <code>CUSTOM_NAME = &quot;fyrrida&quot;</code>。</li>
</ul>
</li>
<li><p><strong>执行构建脚本，生成 fyrrida server &#x2F; gadget</strong>  </p>
<ul>
<li>以 Android 架构为例生成：<br><code>fyrrida-server-16.5.2-android-arm64</code>、<code>fyrrida-gadget-16.5.2-android-arm64.so</code> 等。  </li>
<li>在手机上用 <code>fyrrida-server-16.5.2-android-arm64</code> 替代原版 <code>frida-server</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-获取构建脚本仓库"><a href="#3-获取构建脚本仓库" class="headerlink" title="3. 获取构建脚本仓库"></a>3. 获取构建脚本仓库</h3><p>在 Ubuntu 里：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/fyr/value</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hackcatml/ajeossida.git</span><br><span class="line"><span class="built_in">cd</span> ajeossida</span><br></pre></td></tr></table></figure>
<p>完成后的目录结构是：<br><img src="/images/DexProtector2/img_28.png" alt="img_28.png">&#x2F;home&#x2F;fyr&#x2F;value</p>
<h3 id="4-修改代码，指定要编辑的frida版本："><a href="#4-修改代码，指定要编辑的frida版本：" class="headerlink" title="4. 修改代码，指定要编辑的frida版本："></a>4. 修改代码，指定要编辑的frida版本：</h3><ul>
<li>cd &#x2F;home&#x2F;fyr&#x2F;value&#x2F;ajeossida</li>
</ul>
<p>找到main_ubuntu_android.py修改以下代码</p>
<p>修改代码，指定要编辑的frida版本：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#原代码：</span></span><br><span class="line">CUSTOM_NAME = <span class="string">&quot;ajeossida&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">git_clone_repo</span>():</span><br><span class="line">    repo_url = <span class="string">&quot;https://github.com/frida/frida.git&quot;</span></span><br><span class="line">    destination_dir = os.path.join(os.getcwd(), CUSTOM_NAME)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n[*] Cloning repository <span class="subst">&#123;repo_url&#125;</span> to <span class="subst">&#123;destination_dir&#125;</span>...&quot;</span>)</span><br><span class="line">    run_command(<span class="string">f&quot;git clone --recurse-submodules <span class="subst">&#123;repo_url&#125;</span> <span class="subst">&#123;destination_dir&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#修改后：</span></span><br><span class="line">CUSTOM_NAME = <span class="string">&quot;fyrrida&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">git_clone_repo</span>():</span><br><span class="line">    repo_url = <span class="string">&quot;https://github.com/frida/frida.git&quot;</span></span><br><span class="line">    destination_dir = os.path.join(os.getcwd(), CUSTOM_NAME)</span><br><span class="line">    tag = <span class="string">&quot;16.5.2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n[*] Cloning repository <span class="subst">&#123;repo_url&#125;</span> (tag <span class="subst">&#123;tag&#125;</span>) to <span class="subst">&#123;destination_dir&#125;</span>...&quot;</span>)</span><br><span class="line">    <span class="comment"># --branch 指定 tag/分支，--depth 1 只拉这一版，速度快很多</span></span><br><span class="line">    run_command(</span><br><span class="line">        <span class="string">f&quot;git clone --recurse-submodules --branch <span class="subst">&#123;tag&#125;</span> --depth 1 <span class="subst">&#123;repo_url&#125;</span> <span class="subst">&#123;destination_dir&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>修改代码后指定拉取的是16.5.2的版本，如果不修改的话，原代码会拉取最新的frida版本进行编译。</p>
<p>开始编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 main_ubuntu_android.py</span><br></pre></td></tr></table></figure>

<p>编译成功：<br><img src="/images/DexProtector2/img_21.png" alt="img_21.png"></p>
<p>生成的文件，在assets目录下：<br><img src="/images/DexProtector2/img_22.png" alt="img_22.png"></p>
<h3 id="5-使用编译好的arm64版本，过检测"><a href="#5-使用编译好的arm64版本，过检测" class="headerlink" title="5. 使用编译好的arm64版本，过检测"></a>5. 使用编译好的arm64版本，过检测</h3><ul>
<li><p>解压fyrrida-server-16.5.2-android-arm64.gz，然后推送到手机</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server-16.3.3-android-arm64 /data/local/tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>给权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd /data/local/tmp</span><br><span class="line">chmod 777 frida-server-16.3.3-android-arm64 </span><br></pre></td></tr></table></figure></li>
<li><p>启动frida-server</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frida-server-16.3.3-android-arm64 -l 0.0.0.0:14725</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口转发</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:14725 tcp:14725</span><br></pre></td></tr></table></figure></li>
<li><p>执行脚本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -H <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">14725</span> -f com.<span class="property">Hyatt</span>.<span class="property">hyt</span> -l hook_dexprotectB848.<span class="property">js</span></span><br></pre></td></tr></table></figure>
<p>结果，使用魔改的frida-server，脱离Zygisk Frida Gadget 开源模块。也实现了过检测：<br><img src="/images/DexProtector2/img_29.png" alt="img_29.png"></p>
</li>
</ul>
<p>可以看到：</p>
<p>在不依赖 Zygisk Frida Gadget 模块的前提下</p>
<p>仅使用 魔改后的 fyrrida-server + 迁移后的脚本</p>
<p>同样可以通过当前样本的 DexProtector 检测</p>
<p>这一点非常重要，让环境不再捆死在某个模块 &#x2F; 某个框架上，<br>而是完全掌握在你自己的手里。</p>
<h2 id="把“一次绕过”变成“长期战斗力”"><a href="#把“一次绕过”变成“长期战斗力”" class="headerlink" title="把“一次绕过”变成“长期战斗力”"></a>把“一次绕过”变成“长期战斗力”</h2><p>其实这篇文章做的事，就两件：</p>
<ul>
<li>第一部分，把「版本升级」这件烦心事，拆成了一套能反复照抄的 SOP：入口怎么重找、检测点怎么迁移、特征常量怎么复用；</li>
<li>第二部分，把「环境被盯上」这件隐患，交代成了一条从 Ubuntu 装机、Frida 编译到魔改 server 的完整流水线。</li>
</ul>
<p>前者解决的是<strong>效率问题</strong>：下次 app 再发 6.1.1、6.1.2，你不用一遍遍从 JNI_OnLoad 开始重新看，只要按流程把几个关键偏移和特征重新对齐；<br>后者解决的是<strong>生存问题</strong>：哪怕 Zygisk Frida Gadget 被完全针对，你也可以随时从自己的构建环境里，再产一份新版“fyrrida”扔到手机上继续干活。</p>
<p>如果你已经跟着跑通了一遍，建议现在就做两件小事：</p>
<ol>
<li>把这套 <strong>“版本迁移 SOP” + “魔改 Frida 流水线”</strong>，整理到自己项目&#x2F;笔记里，当成固定模板；</li>
<li>把脚本、IDA 工程、010 编辑器特征、编译脚本，按 app &#x2F; 版本号丢进一个私有仓库，后面每次升级就只是「改几行偏移 + 换一版 server」的体力活。</li>
</ol>
<p>安全对抗本身没有”稳定”一说，DexProtector 也不会因为这一篇文章就“被通杀”。<br>但只要你的方法论是可复用的、环境是自己可控的，每一次小版本更新、每一次新样本，都会变成你工具箱里多长出来的一颗螺丝钉。</p>
<p>(本文内容由id:小佳、fyrlove、roysue 共同完成，属于小佳的系列体系课里的一部分，APK版本是半年前的不影响最新课程)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fyrlove.github.io/2026/01/12/DexProtector2/" data-id="cuidH_OOOkDRBNJzrDt_EmP1V" data-title="从零开始绕过 DexProtector 加固的 Frida 检测（二）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-DexProtector" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/20/DexProtector/" class="article-date">
  <time class="dt-published" datetime="2025-11-20T07:44:20.000Z" itemprop="datePublished">2025-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/20/DexProtector/">从零开始绕过 DexProtector 加固的 Frida 检测</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一个可复盘、可扩展、可工程化的对抗实录"><a href="#一个可复盘、可扩展、可工程化的对抗实录" class="headerlink" title="一个可复盘、可扩展、可工程化的对抗实录"></a>一个可复盘、可扩展、可工程化的对抗实录</h2><p>（本文由 id：小佳、fyrlove、roysue 共同完成）</p>
<p>为保证结论稳健且可迁移，文中所有实验均在以下环境中完成（LineageOS 21 &#x2F; Nexus 5X，Magisk 29.0.0，LSPosed，Zygisk Frida Gadget开源模块（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a> ，Frida Server 16.5.2）</p>
<p>合规：本文仅用于安全研究与对抗评估，旨在帮助甲方团队识别自身加固薄弱点、完善自检与回归策略；不针对具体业务落地攻击，不提供可直接用于对第三方应用的利用脚本。</p>
<p>你在这篇文章里会学到这些硬技能（都能复现）：</p>
<p>1.入口卡位：不死盯 System.loadLibrary，而是改从 __loader_android_dlopen_ext 抓“真实装载面”，提早拿到证据和时序。</p>
<p>2.匿名段定位与转储：用 JNI_OnLoad → 函数指针 → 匿名可执行段 这条线，结合 &#x2F;proc&#x2F;<pid>&#x2F;maps 找段，Frida 直接 dump，只修 text 段也能在 IDA 里反汇到可用程度。</p>
<p>3.最小化修复与类型库引入：在 IDA 里手动补区段、引 android_arm64 &#x2F; gnulnx_arm64 类型库，把 JNIEnv&#x2F;动态注册链条（RegisterNatives&#x2F;FindClass&#x2F;…）梳顺。</p>
<p>4.校验链路拆解：识别 xxHash &#x2F; SHA256 &#x2F; HMAC 的落点（含内联 SHA 指令），用“等式化替换 + 调用点定位（靠 LR 定位调用者）”做最小侵入的绕过。</p>
<p>5.二分法定位：从“可卸载点”开始逐段排除，把“必崩区间”缩到少量函数，再精确打补丁。</p>
<p>6.入口完整性绕过：遇到对“当前段基址”的校验，复制一份干净 text，参数基址替换为干净副本过检。</p>
<p>7.线程面处理：顺着 &#x2F;proc&#x2F;self&#x2F;maps 的反向引用追到 pthread_create，定位监控线程入口。</p>
<p>工程化习惯：每一步都留“能回头验证”的观测点，避免“一刀切”，降低误伤和回归压力。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="01-样本获取与安装"><a href="#01-样本获取与安装" class="headerlink" title="01.样本获取与安装"></a>01.样本获取与安装</h2><p>安装相同的版本，确保app可安装、可启动，并且能够完整复线整个过程。</p>
<h3 id="1-1-样本获取"><a href="#1-1-样本获取" class="headerlink" title="1.1 样本获取"></a>1.1 样本获取</h3><p>样本：Hyatt6.8.0.apkm<br>下载地址：下载地址：<a target="_blank" rel="noopener" href="https://www.apkmirror.com/apk/hyatt-corporation/world-of-hyatt/world-of-hyatt-6-8-0-release/world-of-hyatt-6-8-0-android-apk-download/#google_vignette">https://www.apkmirror.com/apk/hyatt-corporation/world-of-hyatt/world-of-hyatt-6-8-0-release/world-of-hyatt-6-8-0-android-apk-download/#google_vignette</a></p>
<h3 id="1-2-样本安装"><a href="#1-2-样本安装" class="headerlink" title="1.2 样本安装"></a>1.2 样本安装</h3><p>安装方法：通过 APKMirror Installer &#x2F; MT 管理器均可。</p>
<h2 id="02-设备与运行环境"><a href="#02-设备与运行环境" class="headerlink" title="02.设备与运行环境"></a>02.设备与运行环境</h2><p>该基线用于复现与对比。不同 SoC &#x2F; API level &#x2F; ART 实现可能造成“加载顺序、符号可见性、maps 标记”差异。</p>
<h3 id="2-1-设备环境"><a href="#2-1-设备环境" class="headerlink" title="2.1 设备环境"></a>2.1 设备环境</h3><p>设备：Nexus 5X（LineageOS 21）。</p>
<p>Root&#x2F;框架：Magisk 29.0.0、LSPosed、Zygisk Frida Gadget 模块（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a></p>
<p>Frida：frida-server 16.5.2。</p>
<p>PC环境: 肉丝(r0ysue)大佬提供的r0env kali虚拟机（安装了逆向需要的工具和环境配置，能省掉很多安装和环境的问题）。</p>
<h3 id="2-2-运行结果"><a href="#2-2-运行结果" class="headerlink" title="2.2 运行结果"></a>2.2 运行结果</h3><p>不运行 frida-server 时可进入主页但提示要升级；一旦 attach&#x2F;spawn，进程迅速崩溃。</p>
<p>APP点开也不会崩溃，正常进入到主页，只是强制提示必须升级到最新版才可用。说明壳可能没有root检测，或者没有检测到Magisk、LSPosed。<br><img src="/images/DexProtector/%E6%97%A0frida-server-%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8.png" alt="无frida-server-正常启动.png"></p>
<p>frida不管是attach模式还是spawn模式，均会迅速的进程崩溃退出。<br><img src="/images/DexProtector/%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B0%8F%E5%B7%A5%E5%85%B7-%E6%9C%AA%E8%BF%87%E6%8E%89frida%E6%A3%80%E6%B5%8B.png" alt="使用了小工具-未过掉frida检测.png"></p>
<h2 id="03-Java-层入口识别（Application-System-loadLibrary）"><a href="#03-Java-层入口识别（Application-System-loadLibrary）" class="headerlink" title="03.Java 层入口识别（Application &amp; System.loadLibrary）"></a>03.Java 层入口识别（Application &amp; System.loadLibrary）</h2><p>使用jadx对apk进行分析。<br>通过 AndroidManifest 与 Application 类，定位主壳入口与native 装载点，判断逻辑是否下沉到 so。</p>
<h3 id="3-1-AndroidManifest-xml文件简介"><a href="#3-1-AndroidManifest-xml文件简介" class="headerlink" title="3.1 AndroidManifest.xml文件简介"></a>3.1 AndroidManifest.xml文件简介</h3><p>Manifest 是干嘛的？</p>
<p>1.给系统登记应用身份证与四大组件（Activity&#x2F;Service&#x2F;BroadcastReceiver&#x2F;ContentProvider）。</p>
<p>2.声明权限、最低&#x2F;目标系统版本、硬件能力等。</p>
<p>3.配置应用级开关（如是否可调试、是否允许备份、网络安全配置等）。</p>
<p>其中还包含了应用的包名。这只是简述了一个大概，想了解完整的朋友请自行搜索。</p>
<h3 id="3-2-样本apk的AndroidManifest-xml分析"><a href="#3-2-样本apk的AndroidManifest-xml分析" class="headerlink" title="3.2 样本apk的AndroidManifest.xml分析"></a>3.2 样本apk的AndroidManifest.xml分析</h3><p>六十几兆的apkm文件后缀名改成zip后解压，里面有个一百多兆的base.apk，其实大部分内容都在这个base.apk里。jadx-gui打开瞅瞅。<br>1.搜<code>application</code>,找到application节点，这个节点中的name就是主壳入口点，这里是<code>ProtectedTopHyattApplication</code>类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppThemeV4.HorizontalAnimation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name_value&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.Hyatt.hyt.ProtectedTopHyattApplication&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.查找启动Activity，安卓中，启动入口的Activity会有一个intent-filter标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>搜索一下可以发现，入口Activity是SplashActivity:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/SplashTheme&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name_value&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hyt.auth.activities.SplashActivity&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.查看ProtectedTopHyattApplication类，可以看到有一些加载<code>so</code>库的操作，一般都清楚，主要逻辑一般肯定在<code>so</code>库里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">attachBaseContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.attachBaseContext(context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.a((Context) <span class="built_in">this</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;dpboot&quot;</span>);</span><br><span class="line">            wxyrq();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            b.fooldg(<span class="built_in">this</span>, th);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(Context context, String str)</span> &#123;</span><br><span class="line">            System.loadLibrary(c);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">z</span> <span class="operator">=</span> !r.a();</span><br><span class="line">            b = z;</span><br><span class="line">            <span class="keyword">if</span> (z) &#123;</span><br><span class="line">                a = <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir().getAbsolutePath());</span><br><span class="line">                r.a(context);</span><br><span class="line">                r.a(context.getFilesDir().getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>还有很多<code>native</code>函数更加验证了其逻辑在<code>java</code>层几乎没有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> InputStream <span class="title function_">BC</span><span class="params">(Object obj, String str)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">JaucCymn</span><span class="params">(String str, <span class="type">int</span> i, List list)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">byte</span>[] iIbBs();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">s</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">ttghdCr</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wxyrq</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>基本可以确定，Java层只做了引导，核心检测链条在native中。</p>
<h2 id="04-壳的native层入口点"><a href="#04-壳的native层入口点" class="headerlink" title="04.壳的native层入口点"></a>04.壳的native层入口点</h2><p>那就想先hook这个<code>System.loadLibrary</code>函数，但很明显一hook就会崩。<br>那就是要找更早的时机，hook这个<code>System.loadLibrary</code>最底层的函数，那最底层的函数是哪个呢？<br>是linker里的<code>__loader_android_dlopen_ext</code>函数。（参考文章：<a target="_blank" rel="noopener" href="https://huanle19891345.github.io/en/android/art/jni/systemloadlibrary/">SystemLoadLibrary :: 郑欢的学习总结</a><br>）<br>这个函数是全局的，直接取符号就可以。（以下都是frida16.5.2，切记先别上frida17噢）</p>
<h3 id="4-1-启动frida-server，并进行端口转发"><a href="#4-1-启动frida-server，并进行端口转发" class="headerlink" title="4.1 启动frida-server，并进行端口转发"></a>4.1 启动frida-server，并进行端口转发</h3><p>启动frida-server并指定14725，不使用默认端口(27042)，很多检测会检测这个默认端口，所以一开始就处理一下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell                                                                                                                            </span><br><span class="line">bullhead:/ $ su</span><br><span class="line">bullhead:/ # cd /data/local/tmp                                  </span><br><span class="line">bullhead:/data/local/tmp # ./frida-server  -l 0.0.0.0:14725 </span><br></pre></td></tr></table></figure>
<p>进行端口转发：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:14725 tcp:14725</span><br></pre></td></tr></table></figure>
<h3 id="4-2-hook-dlopen，定位so加载时机"><a href="#4-2-hook-dlopen，定位so加载时机" class="headerlink" title="4.2 hook dlopen，定位so加载时机"></a>4.2 hook dlopen，定位so加载时机</h3><p>执行脚本：frida -H 127.0.0.1:14725 -f com.Hyatt.hyt -l hook_dexprotect.js。<br>根据结果分析：hook 日志显示先后加载：libalice.so、libdpboot.so、libdexprotector.so；都输出了”结束”，随后崩溃。<br>崩溃时机在“加载完成之后”（非 .init_array 内）。<br>所以入口库可以基本确定为 libdexprotector.so；<br>检测不在 .init_array，后续应聚焦 JNI_OnLoad 或动态注册链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;__loader_android_dlopen_ext&quot;</span>)</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> pathptr = args[<span class="number">0</span>];</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;path is =&gt; &quot;</span>, pathptr.<span class="title function_">readCString</span>())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hook_dlopen</span>()</span><br></pre></td></tr></table></figure>

<p>运行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt; frida -H 127.0.0.1:14725 -f com.Hyatt.hyt -l hook_dexprotect.js                       </span><br><span class="line">     ____</span><br><span class="line">    / _  |   Frida 16.5.2 - A world-class dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   /_/ |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about &#x27;object&#x27;</span><br><span class="line">   . . . .       exit/quit -&gt; Exit</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at https://frida.re/docs/home/</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   Connected to 127.0.0.1:14725 (id=socket@127.0.0.1:14725)</span><br><span class="line">Spawned `com.Hyatt.hyt`. Resuming main thread!                          </span><br><span class="line">[Remote::com.Hyatt.hyt ]-&gt; path is =&gt;  libframework-connectivity-tiramisu-jni.so</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /system/framework/oat/arm64/org.apache.http.legacy.odex</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/oat/arm64/base.odex</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/split_config.arm64_v8a.apk!/lib/arm64-v8a/libalice.so</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/split_config.arm64_v8a.apk!/lib/arm64-v8a/libdpboot.so</span><br><span class="line">结束</span><br><span class="line">path is =&gt;  /data/app/~~IvxV7LJ9cvtqbZUadvpHsQ==/com.Hyatt.hyt-q8YukchM306gv-ilc-P6Ig==/split_config.arm64_v8a.apk!/lib/arm64-v8a/libdexprotector.so</span><br><span class="line">结束</span><br><span class="line">Process crashed: java.lang.RuntimeException: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029                                                                                   </span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">FATAL EXCEPTION: main</span><br><span class="line">Process: com.Hyatt.hyt, PID: 8020</span><br><span class="line">java.lang.RuntimeException: Unable to create application com.Hyatt.hyt.ProtectedTopHyattApplication: com.Hyatt.hyt.MessageGuardException_RFA6IDc4NiAwMTEyMDMyMTA1MGQwNTgwYTAxMTA3ODAyMDA1ODA2MDA3ODA4MDAxMDU4MGUwMDMwNzgwMjAwNTgwODAwNDA3ODAyMDA1ODBhMDEwMDc4MDQwMDU4MGMwMDMwNzgwMjAwNTgwNDAwMTE1MDMyMTA1MDkwNTgwYTA1NjA3ODAyMDA1ODBhMDZlMDc4MDIwMDU4MDIwMDc4MDIwMDU4MDgwYTgwMjA3ODA0MDA1ODBhMDAxMDExNjAzMjEwNTA1MDU4MGUwMzIwNzgwNjAwNTgwMjAwNzgwMjAwNTgwYzAyOSBbMjAyNTA0MjEtMjAyNTA1MjIxOTAzIGI3OmI3IDM0IGdvb2dsZS9idWxsaGVhZC9idWxsaGVhZDo4LjEuMC9PUE0zLjE3MTAxOS4wMTQvNDUwMzk5ODp1c2VyL3JlbGVhc2Uta2V5cyBibG9ja2VkXSAwMTk5ZjdjOS1hYjI5LTQ0ZGUtYmMzYi04OWI5ODk5N2RiNTg: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029</span><br><span class="line">        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7403)</span><br><span class="line">        at android.app.ActivityThread.-$$Nest$mhandleBindApplication(Unknown Source:0)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2379)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:107)</span><br><span class="line">        at android.os.Looper.loopOnce(Looper.java:232)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:317)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:8592)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:580)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:878)</span><br><span class="line">Caused by: com.Hyatt.hyt.MessageGuardException_RFA6IDc4NiAwMTEyMDMyMTA1MGQwNTgwYTAxMTA3ODAyMDA1ODA2MDA3ODA4MDAxMDU4MGUwMDMwNzgwMjAwNTgwODAwNDA3ODAyMDA1ODBhMDEwMDc4MDQwMDU4MGMwMDMwNzgwMjAwNTgwNDAwMTE1MDMyMTA1MDkwNTgwYTA1NjA3ODAyMDA1ODBhMDZlMDc4MDIwMDU4MDIwMDc4MDIwMDU4MDgwYTgwMjA3ODA0MDA1ODBhMDAxMDExNjAzMjEwNTA1MDU4MGUwMzIwNzgwNjAwNTgwMjAwNzgwMjAwNTgwYzAyOSBbMjAyNTA0MjEtMjAyNTA1MjIxOTAzIGI3OmI3IDM0IGdvb2dsZS9idWxsaGVhZC9idWxsaGVhZDo4LjEuMC9PUE0zLjE3MTAxOS4wMTQvNDUwMzk5ODp1c2VyL3JlbGVhc2Uta2V5cyBibG9ja2VkXSAwMTk5ZjdjOS1hYjI5LTQ0ZGUtYmMzYi04OWI5ODk5N2RiNTg: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.qC(Unknown Source:9)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.xDzqsetu(Unknown Source:0)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.EHo(Unknown Source:6)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$b.fooldg(Unknown Source:1)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.onCreate(Unknown Source:49)</span><br><span class="line">        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1386)</span><br><span class="line">        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7398)</span><br><span class="line">        ... 9 more</span><br><span class="line">Caused by: java.lang.RuntimeException: DP: 786 01120321050d0580a011078020058060078080010580e003078020058080040780200580a0100780400580c0030780200580400115032105090580a0560780200580a06e078020058020078020058080a8020780400580a0010116032105050580e0320780600580200780200580c029</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.ttghdCr(Native Method)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$k.zeHo(Unknown Source:13)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication$k.wolzmlnlx(Unknown Source:472)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.ttghdCr(Native Method)</span><br><span class="line">        at com.Hyatt.hyt.ProtectedTopHyattApplication.onCreate(Unknown Source:44)</span><br><span class="line">        ... 11 more</span><br><span class="line">***</span><br><span class="line">[Remote::com.Hyatt.hyt ]-&gt;</span><br><span class="line"></span><br><span class="line">Thank you for using Frida!</span><br></pre></td></tr></table></figure>

<h3 id="4-3-hook-JNI-OnLoad函数"><a href="#4-3-hook-JNI-OnLoad函数" class="headerlink" title="4.3 hook JNI_OnLoad函数"></a>4.3 hook JNI_OnLoad函数</h3><p>通过再去hook它的JNI_OnLoad函数。<br>发现它的JNI_OnLoad函数也很顺利执行了，但是还是死掉了。<br>我们在onLeave这里加上休眠，它是不会死的，，它可能是在JNI_OnLoad注册了JNI函数，然后外部调用的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> libdexprotector = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libdexprotector.so&quot;</span>)</span><br><span class="line">           <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libdexprotector.<span class="title function_">findExportByName</span>(<span class="string">&quot;JNI_OnLoad&quot;</span>), &#123;</span><br><span class="line">               <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;                    </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JNI_OnLoad onEnter&quot;</span>)</span><br><span class="line">               &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">                   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JNI_OnLoad  结束&quot;</span>)</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">// Thread.sleep(60)</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="/images/DexProtector/img_24.png" alt="img_24.png"></p>
<h2 id="05-定位检测函数位置，追到MMAP匿名内存段里"><a href="#05-定位检测函数位置，追到MMAP匿名内存段里" class="headerlink" title="05.定位检测函数位置，追到MMAP匿名内存段里"></a>05.定位检测函数位置，追到MMAP匿名内存段里</h2><p>检测函数应该不在init_array里面，那还有可能在JNI_OnLoad里面，或者其他native函数里面，刚刚壳的Java层看到了很多native函数，可能是Java层调过来检测的也未必。</p>
<h3 id="5-1-使用IDA分析libdexprotector-so"><a href="#5-1-使用IDA分析libdexprotector-so" class="headerlink" title="5.1 使用IDA分析libdexprotector.so"></a>5.1 使用IDA分析libdexprotector.so</h3><p>先把<code>libdexprotector.so</code>拖到IDA里分析看下，有日志可以，这个so在split_config.arm64_v8a.apk里面，前面安装包里解压出来有，再给它解压就得到<code>libdexprotector.so</code>。</p>
<p>看下<code>JNI_OnLoad</code>函数，发现啥也没干，常见的动态注册也没有，也不是没有，它是把vm传给<code>off_C838</code>这个指针函数了，让它去做事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// w0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_C830 )</span><br><span class="line">    <span class="keyword">return</span> -dword_C830;</span><br><span class="line">  v3 = off_C838(vm, <span class="number">0LL</span>);</span><br><span class="line">  off_C838 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="keyword">return</span> -v3;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65540</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>frida读下这个off_C838指针函数的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loader_android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>,<span class="string">&quot;__loader_android_dlopen_ext&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dlopen address is =&gt; &quot;</span>, loader_android_dlopen_ext)</span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(loader_android_dlopen_ext, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathptr = args[<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;path is =&gt; &quot;</span>, pathptr.<span class="title function_">readCString</span>())</span><br><span class="line">        <span class="keyword">if</span> (pathptr.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;libdexprotector.so&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">match</span> = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">ret</span>) &#123;    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>)    </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">match</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> libdexprotector = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libdexprotector.so&quot;</span>)</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libdexprotector.<span class="title function_">findExportByName</span>(<span class="string">&quot;JNI_OnLoad&quot;</span>), &#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;                    </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 is =&gt; &quot;</span>, libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>())</span><br><span class="line">                &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>跑一下结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 is =&gt;  0x7e25b9a984</span><br></pre></td></tr></table></figure>

<p>再看它属于哪个so：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 module is =&gt; &quot;</span>, <span class="title class_">Process</span>.<span class="title function_">findModuleByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>()))</span><br></pre></td></tr></table></figure>
<p>跑出来结果是null，地址不属于任何已知 module：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 module is =&gt;  null</span><br></pre></td></tr></table></figure>

<p>那么再看这个地址属于哪段内存（findRangeByAddress 显示该地址落在的匿名可执行段），为了防止进程崩溃看不到内存，加上线程休眠60秒：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 mem is =&gt; &quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>())))</span><br><span class="line"><span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>跑出来内存段是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 mem is =&gt;  &#123;<span class="string">&quot;base&quot;</span>:<span class="string">&quot;0x7e25afc000&quot;</span>,<span class="string">&quot;size&quot;</span>:507904,<span class="string">&quot;protection&quot;</span>:<span class="string">&quot;r-x&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>输出cat maps:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`cat /proc/<span class="subst">$&#123;Process.id&#125;</span>/maps | grep <span class="subst">$&#123;Process.findRangeByAddress(libdexprotector.base.add(<span class="number">0xc838</span>).readPointer()).base&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/8467/maps | grep 0x7e24570000</span><br></pre></td></tr></table></figure>

<p>把上面的结果拿去手机APP进程的maps里看下（注意去掉<code>0x7e24570000</code>这里的0x）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bullhead:/ <span class="comment"># cat /proc/8467/maps | grep 7e24570000                                                             </span></span><br><span class="line">7e24570000-7e245ec000 r-xp 00000000 00:00 0                              [anon:15f1e]</span><br></pre></td></tr></table></figure>

<p>GPT解释说，[anon:15f1e] 表示这是一段可执行的可读、私有匿名内存映射，内核为其分配的内部标识符（伪 inode）是 0x15f1e。</p>
<p>执行的函数位于这段匿名内存里，那得把它dump下来分析看看。</p>
<h3 id="5-2-IDA分析结论"><a href="#5-2-IDA分析结论" class="headerlink" title="5.2 IDA分析结论"></a>5.2 IDA分析结论</h3><p>分析到这里，可以知道，DexProtector 将关键逻辑放入运行时生成的匿名映射段；分析需转向内存态 dump与单段反汇。</p>
<h2 id="06-匿名可执行段定位与-proc-maps-交叉验证"><a href="#06-匿名可执行段定位与-proc-maps-交叉验证" class="headerlink" title="06. 匿名可执行段定位与 &#x2F;proc&#x2F;&#x2F;maps 交叉验证"></a>06. 匿名可执行段定位与 &#x2F;proc&#x2F;<pid>&#x2F;maps 交叉验证</h2><p>通过 Frida 拿到 off_C838 所在内存区 base&#x2F;size&#x2F;prot，再交叉 cat &#x2F;proc&#x2F;<pid>&#x2F;maps 验证段属性与范围。<br>Frida转储dump匿名内存：<br>使用frida直接输出一下进程号pid：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 pid is =&gt; &quot;</span>,<span class="title class_">Process</span>.<span class="property">id</span>)</span><br></pre></td></tr></table></figure>
<p>这样就直接有了内存段的起始地址，长度，进程号，再使用线程休眠，把APP卡主使其不闪退：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">off_C838 mem is =&gt;  &#123;<span class="string">&quot;base&quot;</span>:<span class="string">&quot;0x7e25afc000&quot;</span>,<span class="string">&quot;size&quot;</span>:507904,<span class="string">&quot;protection&quot;</span>:<span class="string">&quot;r-x&quot;</span>&#125;</span><br><span class="line">off_C838 pid is =&gt;  8601</span><br></pre></td></tr></table></figure>
<p>如果手速较慢，可以把休眠时间设置为更长。配合以下dump脚本，把匿名内存脱下来：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line">js_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function dump_anon() &#123;</span></span><br><span class="line"><span class="string">    console.log(&quot;开始dump&quot;)</span></span><br><span class="line"><span class="string">    const base = ptr(0x7e25afc000);</span></span><br><span class="line"><span class="string">    const module_size = 507904;</span></span><br><span class="line"><span class="string">    Memory.protect(base, module_size, &#x27;rwx&#x27;);</span></span><br><span class="line"><span class="string">    const soMemory = Memory.readByteArray(base, module_size);</span></span><br><span class="line"><span class="string">    send(&#123;name: &quot;libanon.so&quot;, base: base, size: module_size&#125;, soMemory);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">dump_anon()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        payload = message[<span class="string">&#x27;payload&#x27;</span>]</span><br><span class="line">        so_name = payload[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        base_address = payload[<span class="string">&#x27;base&#x27;</span>]</span><br><span class="line">        size = payload[<span class="string">&#x27;size&#x27;</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Dumping <span class="subst">&#123;so_name&#125;</span> (Base: <span class="subst">&#123;base_address&#125;</span>, Size: <span class="subst">&#123;size&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="comment"># 保存dump的.so文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(so_name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;so_name&#125;</span> dumped successfully!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 附加到目标进程</span></span><br><span class="line">    device = frida.get_usb_device()</span><br><span class="line">    session = device.attach(<span class="number">8601</span>)</span><br><span class="line">    <span class="comment"># 加载Frida脚本</span></span><br><span class="line">    script = session.create_script(js_script)</span><br><span class="line">    <span class="comment"># 设置消息处理函数</span></span><br><span class="line">    script.on(<span class="string">&quot;message&quot;</span>, on_message)</span><br><span class="line">    <span class="comment"># 加载并执行脚本</span></span><br><span class="line">    script.load()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;dumpso.py</span><br><span class="line">开始dump</span><br><span class="line">Dumping libanon.so (Base: 0x7e25afc000, Size: 507904)</span><br><span class="line">libanon.so dumped successfully!</span><br></pre></td></tr></table></figure>
<p>脱下来的libanon.so位于当前执行脚本的目录下。</p>
<h2 id="07-IDA手修匿名内存SO"><a href="#07-IDA手修匿名内存SO" class="headerlink" title="07.IDA手修匿名内存SO"></a>07.IDA手修匿名内存SO</h2><p>拖到010 editor里去可以看到前面一大片都是0，也就是没有ELF的文件头，果然是匿名内存段的风格。大概率也sofix没法修。<br>拖到IDA里，IDA也无法判断这是什么汇编格式，手动选择一个处理器类型：ARM Little-endian ，点击确定。<br><img src="/images/DexProtector/img_3.png" alt="img_3.png"><br>一路点击确定，按照ARM默认设置来分析这段匿名内存so。此时IDA左边已经有了一堆<code>sub_</code>符号，说明IDA是可以正常分析里面的函数的。<br>说明哪怕只有一个text段，IDA也是可以正常反汇编的，哪怕没有导入导出表，没有文件头没有符号表，没有其他区段，也没有关系。<br>接下来开始做基础修复，视图→打开子视图→类型库，导入基础库，右键，加载类型库，导入<code>android_arm64</code>库，和<code>gnulnx_arm64</code>，前者是安卓的，后者是C++的。导进去才能识别<code>JNI</code>的东西，才能有JNIEnv和jclass这些，后续要改参数类型识别JNI里面的函数如RegisterNatives、FindClass那些。<br><img src="/images/DexProtector/img_4.png" alt="img_4.png"></p>
<h2 id="08-IDA手修匿名内存SO-2-匿名指针函数代码追踪"><a href="#08-IDA手修匿名内存SO-2-匿名指针函数代码追踪" class="headerlink" title="08.IDA手修匿名内存SO(2),匿名指针函数代码追踪"></a>08.IDA手修匿名内存SO(2),匿名指针函数代码追踪</h2><p>以 ARM64 Little-endian 打开；导入 android_arm64 &#x2F; gnulnx_arm64 类型库以恢复 JNI&#x2F;GLIBC 符号语义；</p>
<p>手工增加 rodata 等伪区段解决“无效内存访问”。</p>
<h3 id="8-1-寻找真实执行的函数"><a href="#8-1-寻找真实执行的函数" class="headerlink" title="8.1 寻找真实执行的函数"></a>8.1 寻找真实执行的函数</h3><p>到这里还没找到前面实际执行的<code>off_C838</code>函数在哪里，可以把函数指针地址减去基地址即可得到真实的偏移。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;off_C838 real offset =&gt; &quot;</span>,libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>().<span class="title function_">sub</span>(<span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>()).<span class="property">base</span>))</span><br></pre></td></tr></table></figure>
<p>执行一下，也就是sub_4e984。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_C838 real offset =&gt;  0x4e984</span><br></pre></td></tr></table></figure>

<h3 id="8-2-无效内存访问修复"><a href="#8-2-无效内存访问修复" class="headerlink" title="8.2 无效内存访问修复"></a>8.2 无效内存访问修复</h3><p>在IDA里按g跳到0x4e984的地址，就是sub_4e984的函数头，按F5汇编即可开始分析。<br>首先有些报红字的，无效内存访问报错：<br><img src="/images/DexProtector/img_5.png" alt="img_5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MEMORY[0x8A800] = v1;</span><br><span class="line">MEMORY[0x8A808] = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 168LL))(v7, v6);</span><br></pre></td></tr></table></figure>
<p>其实就是dump下来的so里没有数据段的原因，视图→打开子视图→区段，右键→添加区段，区段名称可以取rodata，开始地址可以填0x8A800，结束地址0x8B800，给大一些。后面再遇到红字的，可以继续扩大一些，覆盖到红字指向地址的范围即可。<br>再回到sub_4e984函数再按一下F5，红字就消失了，变成了：<br><img src="/images/DexProtector/img_6.png" alt="img_6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unk_8A800 = v1;</span><br><span class="line">unk_8A808 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 168LL))(v7, v6);</span><br></pre></td></tr></table></figure>
<p>点在<code>unk_8A800</code>上按x，就可以追踪交叉引用了，可以看到有四处引用到这个地址:<br><img src="/images/DexProtector/img_7.png" alt="img_7.png"><br>前面JNIOnLoad里面就一个vm参数传到off_C838了，那这里<code>sub_4e984</code>参数类型就是<code>JavaVM*</code>，按y修改。修改成功后，一些指针也会从这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*(<span class="type">unsigned</span> <span class="type">int</span> (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)a1 + <span class="number">48LL</span>))(a1, &amp;v7, <span class="number">65540</span>) )</span><br></pre></td></tr></table></figure>
<p>变成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*a1)-&gt;GetEnv(a1, (<span class="type">void</span> **)&amp;v8, <span class="number">65540LL</span>) )</span><br></pre></td></tr></table></figure>
<p>完整的结果：<br><img src="/images/DexProtector/img_8.png" alt="img_8.png"><br>识别出来了env里的指针，这也是前面导入库发挥了作用。<br>接下来即可进行基本的逐行手撕了，以及不停地做一些尝试绕过检测的hook了。在逆向中也是这样不断地做尝试的。<br>接下来理论上要进行全量分析了，逆向到最后，归根结底都是体力活罢了。</p>
<h2 id="09-JNIEnv-恢复与动态注册链梳理"><a href="#09-JNIEnv-恢复与动态注册链梳理" class="headerlink" title="09.JNIEnv 恢复与动态注册链梳理"></a>09.JNIEnv 恢复与动态注册链梳理</h2><p>逐行手撕定位敏感函数</p>
<h3 id="9-1-JNIEnv-恢复"><a href="#9-1-JNIEnv-恢复" class="headerlink" title="9.1 JNIEnv 恢复"></a>9.1 JNIEnv 恢复</h3><p>继续分析<code>sub_4e984</code>，a1获取env传给v7了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*a1)-&gt;GetEnv(a1, (<span class="type">void</span> **)&amp;v7, <span class="number">65540</span>) </span><br></pre></td></tr></table></figure>
<p>那v7的参数类型就是JNIEnv*，在定义那里<code>__int64 v8;</code>按y修改一下参数类型。原本的几个不明意义的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">136LL</span>))(v7);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(v3 + <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = sub_4EBE0(v7);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = v4;</span><br><span class="line">      <span class="keyword">if</span> ( !(*(<span class="type">unsigned</span> __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">1824LL</span>))(v7) )</span><br><span class="line">        sub_4EFC4(v7, v5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(<span class="type">unsigned</span> __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">1824LL</span>))(v7) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">120LL</span>))(v7);</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(__int64))(*(_QWORD *)v7 + <span class="number">136LL</span>))(v7);</span><br><span class="line">      unk_8A808 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + <span class="number">168LL</span>))(v7, v6);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>修改成功后，又变得有意义了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">&#123;</span><br><span class="line">  (*v7)-&gt;ExceptionClear(v7);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(v3 + <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v4 = sub_4EBE0(v7);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( !(*v7)-&gt;ExceptionCheck(v7) )</span><br><span class="line">      sub_4EFC4(v7, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (*v7)-&gt;ExceptionCheck(v7) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (__int64)(*v7)-&gt;ExceptionOccurred(v7);</span><br><span class="line">    (*v7)-&gt;ExceptionClear(v7);</span><br><span class="line">    unk_8A808 = (*v7)-&gt;NewGlobalRef(v7, (jobject)v6);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-动态注册链路梳理，函数分析，发现重点可疑目标"><a href="#9-2-动态注册链路梳理，函数分析，发现重点可疑目标" class="headerlink" title="9.2 动态注册链路梳理，函数分析，发现重点可疑目标"></a>9.2 动态注册链路梳理，函数分析，发现重点可疑目标</h3><p>从上往下看，接下来它把v8这个<code>jnienv</code>依次传给了<code>sub_4EAA0</code>、<code>sub_4EBE0</code>、<code>sub_4EFC4</code>这几个函数，这些函数都要跟进去逐行查看，每一行到底做了什么。<br>先看第一个<code>sub_4EAA0</code>，唯一的参数a1修改类型为<code>JNIEnv*</code>，下面立刻动态注册的API出来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint (*RegisterNatives)(JNIEnv *, jclass, <span class="type">const</span> JNINativeMethod *, jint); </span><br></pre></td></tr></table></figure>
<p>动态注册的函数列表保存在v6参数中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v6[<span class="number">0</span>] = v9;</span><br><span class="line">v6[<span class="number">1</span>] = sub_40814(&amp;unk_681F);</span><br><span class="line">v6[<span class="number">2</span>] = sub_4F0F4;</span><br><span class="line">v6[<span class="number">3</span>] = v8;</span><br><span class="line">v6[<span class="number">4</span>] = sub_40814(&amp;unk_346B);</span><br><span class="line">v6[<span class="number">5</span>] = sub_4F254;</span><br><span class="line">v6[<span class="number">6</span>] = v7;</span><br><span class="line">v4 = sub_40814(&amp;unk_5523);</span><br><span class="line">RegisterNatives = (*a1)-&gt;RegisterNatives;</span><br><span class="line">v6[<span class="number">7</span>] = v4;</span><br><span class="line">v6[<span class="number">8</span>] = MEMORY[<span class="number">0x82988</span>];</span><br><span class="line"><span class="keyword">if</span> ( RegisterNatives(a1, (jclass)v3, (<span class="type">const</span> JNINativeMethod *)v6, <span class="number">3</span>) )</span><br></pre></td></tr></table></figure>
<p>其中<code>sub_4F0F4</code>开辟了一段字节数组，像是初始化函数，先不看。<br><code>sub_4F254</code>特别长，业务逻辑十分丰富，还夹杂着很多Java类方法的使用，大概五六百行，一眼看不出逻辑，需要细细拆分研究。这里是接下来分析的重点。</p>
<h2 id="10-关键函数-sub-4F254-的行为探测（返回值与入栈点）"><a href="#10-关键函数-sub-4F254-的行为探测（返回值与入栈点）" class="headerlink" title="10.关键函数 sub_4F254 的行为探测（返回值与入栈点）"></a>10.关键函数 sub_4F254 的行为探测（返回值与入栈点）</h2><p>直接hook这个sub_4F254，观察一下结果，并首次尝试修改结果过检测：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x4F254</span>),&#123;</span><br><span class="line">     <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x4F254 &quot;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onLeave  0x4F254  &quot;</span>,retval.<span class="title function_">toInt32</span>())   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onEnter  0x4F254 </span><br><span class="line">onEnter  0x4F254 </span><br><span class="line">onLeave  0x4F254   0</span><br><span class="line">onLeave  0x4F254   1</span><br></pre></td></tr></table></figure>
<p>尝试修改返回值为0，测试是否能过掉检测：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x4F254</span>),&#123;</span><br><span class="line">     <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x4F254 &quot;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        retval.<span class="title function_">replace</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onLeave  0x4F254  &quot;</span>,retval.<span class="title function_">toInt32</span>())   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>返回值修改为0，成功。但是app依然崩溃了，果然，一切不会这么简单。继续分析中间的逻辑，检测大概率就是在中间的逻辑完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onEnter  0x4F254 </span><br><span class="line">onEnter  0x4F254 </span><br><span class="line">onLeave  0x4F254   0</span><br><span class="line">onLeave  0x4F254   0</span><br></pre></td></tr></table></figure>
<p>必须深入其内部校验路径（而非仅“短路返回”）——尤其是完整性&#x2F;哈希相关分支。</p>
<h2 id="11-浮点运算特征联合GPT定位CRC哈希算法"><a href="#11-浮点运算特征联合GPT定位CRC哈希算法" class="headerlink" title="11.浮点运算特征联合GPT定位CRC哈希算法"></a>11.浮点运算特征联合GPT定位CRC哈希算法</h2><p>进这个<code>sub_4F254</code>函数，从上往下看，第一个可疑的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v34 == sub_161E8(unk_82948, unk_82990 - unk_82948, &amp;v75) )</span><br><span class="line">    sub_14D24(byte_872AC, <span class="number">64</span>, v32, <span class="number">32</span>, v33);</span><br></pre></td></tr></table></figure>
<p>点进<code>sub_161E8</code>函数，可以看到大量浮点数寄存器，<code>vaddq_s64</code>、<code>veorq_s8</code>、<code>vorrq_s8</code>，一般这种不是哈希就是加解密，再结合函数开头就有一些初始常量，大概率是哈希：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v12 = v10 ^ <span class="number">0x7465646279746573L</span>L;</span><br><span class="line">v13 = v10 ^ <span class="number">0x646F72616E646F6DL</span>L;</span><br><span class="line">v14 = a2 &lt;&lt; <span class="number">56</span>;</span><br><span class="line">v15 = *a3 ^ <span class="number">0x6C7967656E657261L</span>L;</span><br><span class="line">v16 = *a3 ^ <span class="number">0x736F6D6570736575L</span>L;</span><br></pre></td></tr></table></figure>
<p>其实猜算法这件事情，最拿手的应该是GPT，直接整个F5全部复制黏贴过去问GPT，GPT告诉我这很像是SipHash哈希算法的实现，具体是 SipHash-2-4 变种（2轮压缩，4轮最终化），真假先不做评价，先hook看下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> libanon = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(libdexprotector.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xC838</span>).<span class="title function_">readPointer</span>()).<span class="property">base</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x161E8</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>)</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 leave&quot;</span>,ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>单纯hook结果没什么特别：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub_161E8 enter</span><br><span class="line">sub_161E8 leave 0xff4414fe9bf00ecd</span><br><span class="line">sub_161E8 enter</span><br><span class="line">sub_161E8 leave 0xff4414fe9bf00ecd</span><br></pre></td></tr></table></figure>
<p>但从结果来看这里其实是做crc哈希校验的地方。sub_161E8 属于完整性哈希链路；但仅满足判等未必足以阻断后续自校验&#x2F;熔断。</p>
<h2 id="12-HMAC-SHA256-路径确认（内联-SHA-指令识别）"><a href="#12-HMAC-SHA256-路径确认（内联-SHA-指令识别）" class="headerlink" title="12.HMAC-SHA256 路径确认（内联 SHA 指令识别）"></a>12.HMAC-SHA256 路径确认（内联 SHA 指令识别）</h2><p>全局hex搜挂哈希魔术定位CRC校验</p>
<h3 id="12-1-分析定位-HMAC-SHA256"><a href="#12-1-分析定位-HMAC-SHA256" class="headerlink" title="12.1 分析定位 HMAC-SHA256"></a>12.1 分析定位 HMAC-SHA256</h3><p>问了下GPT，<code>0xff4414fe9bf00ecd</code>这个值看起来像是一个64位的哈希值（16个十六进制字符 * 4位&#x2F;字符 &#x3D; 64位）。根据其长度和格式，它最有可能来自以下几种哈希算法：</p>
<ul>
<li>xxHash: 一个极快的非加密哈希算法，64位版本会生成一个16字符的十六进制值。这是一个非常强有力的候选。</li>
<li>MurmurHash3: 另一个经典的非加密哈希函数，其128位版本更常见，但它也有64位的变体。</li>
<li>CityHash, FarmHash: 由Google发布的哈希函数系列，用于类似的目的，能产生64位哈希。</li>
<li>SipHash: 虽然也是64位输出，但它更注重防止哈希洪水攻击，常用在编程语言的字典实现中（如Python、Ruby）。<br>当然如果是结果导向的话，逆完之后发现是<code>xxHash</code>算法。</li>
<li></li>
</ul>
<p>继续回到<code>sub_4F254</code>里面，如果返回值与v34相等，则会进入<code>sub_14D24</code>，那再进入<code>sub_14D24</code>看下做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v34 = unk_8A810;</span><br><span class="line"><span class="keyword">if</span> ( v34 == sub_161E8(unk_82948, unk_82990 - unk_82948, &amp;v75) )</span><br><span class="line">    sub_14D24(byte_872AC, <span class="number">64</span>, v32, <span class="number">32</span>, v33);</span><br></pre></td></tr></table></figure>
<p>在<code>sub_14D24</code>里面可以看到，<code>sub_2FA44</code>做了一些初始化，<code>sub_304A8</code>、<code>sub_30B14</code>里面则演都不演了，直接内联汇编了SHA256的算法，也可能是编译优化的产物，为了加快运行速度。<br><img src="/images/DexProtector/img_9.png" alt="img_9.png"><br>两次<code>SHA256</code>的计算，那合理猜测是做的<code>HMAC</code>算法，合理猜测<code>sub_14D24</code>就是<code>HMAC</code>的入口。</p>
<h3 id="12-2-通过010editor，快速查找使用了sha256的函数"><a href="#12-2-通过010editor，快速查找使用了sha256的函数" class="headerlink" title="12.2 通过010editor，快速查找使用了sha256的函数"></a>12.2 通过<code>010editor</code>，快速查找使用了sha256的函数</h3><p>打开IDA的选项→常规，操作码字节数改成8，点确定，随便找个<code>SHA256</code>里面已经优化好的汇编，看下操作码，比如这一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM:<span class="number">0000000000030708</span> <span class="number">83</span> <span class="number">28</span> <span class="number">28</span> <span class="number">5</span>E   SHA256SU0       V3.<span class="number">4</span>S, V4.<span class="number">4</span>S</span><br></pre></td></tr></table></figure>
<p>就是<code>8328285E</code>，把<code>linanon.so</code>文件拖到<code>010 editor</code>里面去，全局搜这个二进制，可以得到如图12处结果。<br>复制行号，到IDA里去看了下，前六处属于刚刚的<code>sub_304A8</code>函数，后六处属于<code>sub_30B14</code>函数，也就是一共就俩函数进行SHA256校验。</p>
<h2 id="13-等式化替换策略：让-CRC-Hash“必相等”"><a href="#13-等式化替换策略：让-CRC-Hash“必相等”" class="headerlink" title="13.等式化替换策略：让 CRC&#x2F;Hash“必相等”"></a>13.等式化替换策略：让 CRC&#x2F;Hash“必相等”</h2><p>基于 lr 获取调用点（0x4f5a4 &#x2F; 0x4f6cc &#x2F; 0x5c494），对 sub_161E8 的返回值在不同入栈点替换为预期内存值（0x8A810&#x2F;0x8AB20）以通过等式校验。</p>
<h3 id="13-1-HMAC-SHA256入口函数分析"><a href="#13-1-HMAC-SHA256入口函数分析" class="headerlink" title="13.1 HMAC-SHA256入口函数分析"></a>13.1 <code>HMAC-SHA256</code>入口函数分析</h3><p>再回到<code>sub_14D24</code>可以发现，先调用了<code>sub_304A8</code>函数之后，又立即调用了<code>sub_30B14</code>，也就是<code>sub_14D24</code>应该是<code>HMAC-SHA256</code>的入口。<br>那同样hook看下有没有经过<code>sub_14D24</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(libanon.base.add(<span class="number">0x14D24</span>),&#123;</span><br><span class="line">    onEnter:function(args)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;sub_14D24 enter&quot;</span>,this.context.lr.sub(libanon.base))</span><br><span class="line">    &#125;,onLeave:function(ret)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;sub_14D24 leave&quot;</span>,ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_14D24 enter 0x4ee38</span><br><span class="line">sub_14D24 leave 0x7ff213aa70</span><br></pre></td></tr></table></figure>
<p>而此处调用的汇编地址是<code>0x4F5C8</code>，也就是<code>sub_4F254+354</code>处，很明显不是<code>0x4ee38</code>，也就是此处没有进入执行<code>sub_14D24</code>的逻辑。<br><img src="/images/DexProtector/img_10.png" alt="img_10.png"></p>
<h3 id="13-2-HOOK绕过CRC校验使其相等"><a href="#13-2-HOOK绕过CRC校验使其相等" class="headerlink" title="13.2 HOOK绕过CRC校验使其相等"></a>13.2 HOOK绕过CRC校验使其相等</h3><p>那如何让它进入呢？只要<code>v34</code>与<code>sub_161E8</code>运行的结果相等即可进入。这其实就是一段CRC的内存校验，可以写个脚本来使其相等。<br>首先看下有哪些地方对<code>sub_161E8</code>进行了校验，前面的代码加上一句<code>lr</code>返回值地址的输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>,<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>))</span><br></pre></td></tr></table></figure>

<p>跑一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub_161E8 enter 0x4f5a4</span><br><span class="line">sub_161E8 leave 0x7799165d5282bf95</span><br><span class="line">sub_161E8 enter 0x4f6cc</span><br><span class="line">sub_161E8 leave 0x7799165d5282bf95</span><br></pre></td></tr></table></figure>
<p>两处进行了校验，<code>0x4f5a4</code>和<code>0x4f6cc</code>处，那就把这两处的返回值都看一下，要等于哪处内存的值，才能进入相等后的逻辑：<br>通过x查找引用，发现还有一个地方也使用sub_161E8做了比较<code>0x5C494</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash_crc = &#123;</span><br><span class="line">        <span class="string">&quot;0x4f5a4&quot;</span> : <span class="number">0x8A810</span>,</span><br><span class="line">        <span class="string">&quot;0x4f6cc&quot;</span> : <span class="number">0x8A810</span>,</span><br><span class="line">        <span class="string">&quot;0x5c494&quot;</span> : <span class="number">0x8AB20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终完整的相等逻辑代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="title function_">add</span>(<span class="number">0x161E8</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 enter&quot;</span>,<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon))</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon)</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()])&#123;</span><br><span class="line">            ret.<span class="title function_">replace</span>(libanon.<span class="title function_">add</span>(hash_crc[<span class="variable language_">this</span>.<span class="property">lr</span>.<span class="title function_">toString</span>()]).<span class="title function_">readU64</span>())</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sub_161E8 leave&quot;</span>,ret)</span><br><span class="line">        &#125;                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>为何<code>lr</code>寄存器要使用<code>onEnter</code>时机的而不能是<code>onLeave</code>时机的？因为frida在hook替换的时候已经把lr修改的面目全非了，这涉及到native hook的调用顺序和核心原理，可以问问GPT，这里不再赘述。所以得保留原来的lr才是正确的。<br>跑一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub_14D24 enter 0x4ee38</span><br><span class="line">sub_14D24 leave 0x7ff213aa70</span><br><span class="line">sub_161E8 enter 0x4f5a4</span><br><span class="line">sub_161E8 leave 0x40a05af38cb96159</span><br><span class="line">sub_14D24 enter 0x4f5c8</span><br><span class="line">sub_14D24 leave 0x7ff2139460</span><br><span class="line">sub_161E8 enter 0x4f6cc</span><br><span class="line">sub_161E8 leave 0x40a05af38cb96159</span><br></pre></td></tr></table></figure>
<p>很明显替换成功了，<code>sub_161E8</code>返回值由<code>0x7799165d5282bf95</code>替换成了<code>0x40a05af38cb96159</code>，且进入了<code>0x4f5c8</code>处的<code>sub_14D24</code>函数计算逻辑。<br>只是很不幸，还是没能绕过，进程还是崩溃了。胜败乃兵家常事，英雄请重新来过。</p>
<p>SO里的每一行汇编都要扒光，要让它没有秘密。全扒光就拥有了维多利亚的秘密。</p>
<p>该策略仅能跨过“第一道门”，后续仍有追加校验&#x2F;副通道检测（如 maps 轮询 &#x2F; 线程监控）。</p>
<h2 id="14-字符串解密链与-proc-self-maps-检测点确认"><a href="#14-字符串解密链与-proc-self-maps-检测点确认" class="headerlink" title="14.字符串解密链与 &#x2F;proc&#x2F;self&#x2F;maps 检测点确认"></a>14.字符串解密链与 &#x2F;proc&#x2F;self&#x2F;maps 检测点确认</h2><p>分析发现字符串处理，关键信息</p>
<h3 id="14-1-发现字符串检测"><a href="#14-1-发现字符串检测" class="headerlink" title="14.1 发现字符串检测"></a>14.1 发现字符串检测</h3><p>sub_50130-&gt;修改a1类型为JNIEnv之后，发现调用了字符串的方法：<br><img src="/images/DexProtector/img_12.png" alt="img_12.png"><br>v4是一个类，传入了v19，那么猜测sub_55650可能是一个字符串解密的函数，下面的sub_40814似乎也是一个字符串揭秘函数，<br>那么接下来直接hook它们</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sub_55650(&amp;unk_87419, v19, <span class="number">257</span>);</span><br><span class="line">  v4 = (*a1)-&gt;FindClass(a1, v19);</span><br><span class="line">  <span class="keyword">if</span> ( (*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">46</span>;</span><br><span class="line">  v5 = (<span class="type">void</span> *)sub_3CF88();</span><br><span class="line">  sub_55650(&amp;unk_87218, v18, <span class="number">65</span>);</span><br><span class="line">  GetStaticMethodID = (*a1)-&gt;GetStaticMethodID;</span><br><span class="line">  v7 = sub_40814(dword_346B, &amp;v16, <span class="number">22</span>);</span><br><span class="line">  v8 = GetStaticMethodID(a1, v5, v18, v7);</span><br><span class="line">  <span class="keyword">if</span> ( (*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">46</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v11 = (*a1)-&gt;ToReflectedMethod(a1, v5, v8, <span class="number">1</span>);</span><br><span class="line">    sub_55650(&amp;unk_872F5, v17, <span class="number">65</span>);</span><br><span class="line">    v12 = (*a1)-&gt;GetStaticMethodID;</span><br><span class="line">    v13 = sub_40814(dword_3EC3, &amp;v15, <span class="number">24</span>);</span><br><span class="line">    v14 = v12(a1, v4, v17, v13);</span><br><span class="line">    v9 = <span class="number">46</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      (*a1)-&gt;CallStaticVoidMethod(a1, v4, v14, v11, a2);</span><br><span class="line">      <span class="keyword">if</span> ( (*a1)-&gt;ExceptionCheck(a1) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">46</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x55650</span>),&#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x55650]&quot;</span>,retval.<span class="title function_">readCString</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//Interceptor.attach(libanon.base.add(0x40814),&#123; //0x40814这个函数内部做了inlinehook，直接这样hook，就崩溃了</span></span><br><span class="line"><span class="comment">//那么这个我们可以偏移4条指令进行hook </span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x40814</span>+ <span class="number">4</span>*<span class="number">4</span>),&#123; </span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(libanon.<span class="property">base</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">lr</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x40814]&quot;</span>,retval.<span class="title function_">readCString</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x40814]&quot;</span>,retval.<span class="title function_">readCString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：<br><img src="/images/DexProtector/img_13.png" alt="img_13.png"></p>
<h3 id="14-2-通过输出的libart-so的地址，找到调用函数，并修改返回值"><a href="#14-2-通过输出的libart-so的地址，找到调用函数，并修改返回值" class="headerlink" title="14.2 通过输出的libart.so的地址，找到调用函数，并修改返回值"></a>14.2 通过输出的libart.so的地址，找到调用函数，并修改返回值</h3><p>分析这个结果，发现检测了分段maps,这里通过libart.so的0x61a78去找到函数进行hook，检测一般都是通过这里进行。<br>在ida中g这个0x61a78，找到调用的函数为sub_61974，hook这个看一下结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x61974</span>),&#123; </span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;      </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x61974]&quot;</span>,retval.<span class="title function_">toInt32</span>(),<span class="string">&quot; lr =&gt; &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果，发现返回值是786。在ida中分析sub_61974，返回值786是出现了异常，正常返回应该是v1&#x3D;0，那么我们这里hook替换一下返回值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x61974 =&gt;  786  lr =&gt;  0x4f630</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这里修改返回之后，运行依然崩溃了，但是日志输出要比之前多一些了。<br>说明 maps 检测非唯一触发，且与其他面耦合。</p>
<h2 id="15-二分排除法缩窗（定位“必崩区间”）"><a href="#15-二分排除法缩窗（定位“必崩区间”）" class="headerlink" title="15.二分排除法缩窗（定位“必崩区间”）"></a>15.二分排除法缩窗（定位“必崩区间”）</h2><p>注意，这里开始，我们切换Zygisk Frida Gadget，使用方法在这里（<a target="_blank" rel="noopener" href="https://github.com/sucsand/sucsand%EF%BC%89">https://github.com/sucsand/sucsand）</a> ，绕过一部分基于ptrace的检测，并开始使用二分排除法，来定位出问题的地方。<br>将“必崩窗口”缩至少量函数，有利于后续精确打补丁。</p>
<h3 id="15-1-使用Zygisk-Frida-Gadget模块"><a href="#15-1-使用Zygisk-Frida-Gadget模块" class="headerlink" title="15.1 使用Zygisk Frida Gadget模块"></a>15.1 使用Zygisk Frida Gadget模块</h3><p>注意:从frida-server换到Zygisk Frida Gadget模块后，重启一下手机。使用Zygisk Frida Gadget的时候，要先正常启动过一次app。<br>在sucsand中，勾选酒店app，并设置200延迟。<br><img src="/images/DexProtector/img_22.png" alt="img_22.png"></p>
<p>配置完成后，在桌面的酒店应用图标长按，然后点强行停止，然后再重新打开app，此时app启动会被阻塞：<br><img src="/images/DexProtector/%E4%BD%BF%E7%94%A8zygisk-gadget.png" alt="使用zygisk-gadget.png"><br>现在开始使用frida -H 192.168.0.101:9999 -F -l dexprotect2.js 来执行脚本。9999是模块内置的端口号。<br><img src="/images/DexProtector/img_23.png" alt="img_23.png"></p>
<h3 id="15-2-继续分析检测点"><a href="#15-2-继续分析检测点" class="headerlink" title="15.2 继续分析检测点"></a>15.2 继续分析检测点</h3><p>继续往下分析sub_4F254，现在都是体力活儿，只能挨着往下分析，看着确实无聊。</p>
<p>现在来到了sub_27398,这里看着像是在做检测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v41 = sub_27398(v39, &amp;v70, <span class="number">32</span>, &amp;v69, <span class="number">8</span>, &amp;v68, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)v68 != unk_872EC</span><br><span class="line">  || BYTE1(v68) != unk_872ED</span><br><span class="line">  || BYTE2(v68) != unk_872EE</span><br><span class="line">  || HIBYTE(v68) != unk_872EF )</span><br><span class="line">&#123;</span><br><span class="line">  sub_62F48(<span class="number">11</span>);</span><br><span class="line">  v41 = sub_62F74(&amp;v68, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">v24 = v74;</span><br><span class="line"><span class="keyword">if</span> ( !v74 )</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x27398</span>),&#123;     <span class="comment">//fail</span></span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lr</span> = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">lr</span>.<span class="title function_">sub</span>(libanon.<span class="property">base</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x27398 &quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>)</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">detachAll</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x27398] &quot;</span>,retval.<span class="title function_">toInt32</span>(),<span class="string">&quot;lr&quot;</span>,<span class="variable language_">this</span>.<span class="property">lr</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在这里执行全部卸载，发现还是崩溃了，说明在这里之前就已经对整个内存进行检测了，那么我们要找一个没有检测的点，来缩小排查范围。<br>找这个点的原则是，这个函数只调用了一次，并且卸载后能保证app顺利运行。<br>4F254 ，可以<br>593FC ，可以<br>27398 ，不行<br>那么就可以确定， 问题出在593FC~27398之间。那么我们又从这个中间的函数开始进行排查，一步一步缩小位置：<br>3EA0C ，可以<br>15128 ，不行<br>那么现在进一步缩小到了3EA0C～15128之间，分析的范围大大减小了：<br><img src="/images/DexProtector/img_14.png" alt="img_14.png"><br>进一步分析，sub_14F7C，没有看出什么问题，暂时排除。</p>
<p>目前这些函数都没有分析出什么有效的信息。</p>
<h2 id="16-入口校验绕过（复制-text-→-替换参数基址）"><a href="#16-入口校验绕过（复制-text-→-替换参数基址）" class="headerlink" title="16.入口校验绕过（复制 text → 替换参数基址）"></a>16.入口校验绕过（复制 text → 替换参数基址）</h2><p>在没有什么有效信息的情况下，当一次侥幸哥，进行暴力拆解</p>
<h3 id="16-1-发现对入口函数进行了检测"><a href="#16-1-发现对入口函数进行了检测" class="headerlink" title="16.1 发现对入口函数进行了检测"></a>16.1 发现对入口函数进行了检测</h3><p>上面分析出来的sha256的sub_304A8，来hook一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x304A8</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x304A8 &quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],<span class="string">&quot;base &quot;</span>,rangeDetails.<span class="property">base</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：<br><img src="/images/DexProtector/img_15.png" alt="img_15.png"><br>通过分析结果，发现304A8，对入口的函数也做了检测</p>
<h3 id="16-2-处理对入口函数检测"><a href="#16-2-处理对入口函数检测" class="headerlink" title="16.2 处理对入口函数检测"></a>16.2 处理对入口函数检测</h3><p>针对 sub_304A8 的入口校验：</p>
<p>先把匿名段 text 拷贝一份 origin；</p>
<p>若发现其校验针对当前段基址，则把参数中的基址替换为 origin（干净副本）以规避校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> origin</span><br><span class="line"><span class="keyword">var</span> size=<span class="number">0x7a2a0</span></span><br><span class="line"></span><br><span class="line">origin = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(size)</span><br><span class="line">origin.<span class="title function_">writeByteArray</span>(libanon.<span class="property">base</span>.<span class="title function_">readByteArray</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x304A8</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">1</span>].<span class="title function_">toString</span>() === libanon.<span class="property">base</span>.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">            <span class="keyword">var</span> rangeDetails = <span class="title class_">Process</span>.<span class="title function_">findRangeByAddress</span>(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter  0x304A8 &quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],<span class="string">&quot;base &quot;</span>,rangeDetails.<span class="property">base</span>)</span><br><span class="line">            args[<span class="number">1</span>] = origin</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0x304A8] 替换成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时已经过掉了检测，并进入了首页。但是输出看到，不停在刷，maps检测明显开了线程。<br><img src="/images/DexProtector/img_16.png" alt="img_16.png"></p>
<h2 id="17-线程面收敛：定位-pthread-create-入口并“即刻返回”"><a href="#17-线程面收敛：定位-pthread-create-入口并“即刻返回”" class="headerlink" title="17. 线程面收敛：定位 pthread_create 入口并“即刻返回”"></a>17. 线程面收敛：定位 pthread_create 入口并“即刻返回”</h2><p>虽然已经完成了过掉frida检测，为了完美一点，我们再来找到线程并处理掉它。</p>
<h3 id="17-1-定位pthread-create"><a href="#17-1-定位pthread-create" class="headerlink" title="17.1 定位pthread_create"></a>17.1 定位<code>pthread_create</code></h3><p>根据 “&#x2F;proc&#x2F;self&#x2F;maps” 调用的反向引用，追到 pthread_create</p>
<p>我们使用<code>[0x40814] /proc/self/maps  lr =&gt;  0x3b66c</code>的0x3b66c，在ids中按x，一步一步向上查找。最终发现了sub_7A230，这个看起来很像是pthread_create函数：<br><img src="/images/DexProtector/img_17.png" alt="img_17.png"></p>
<p>pthread_create函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_t</span> *thread,                  <span class="comment">// [out] 新线程ID</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">// [in]  线程属性(可为NULL)</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),     <span class="comment">// [in]  线程入口函数</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *arg                           <span class="comment">// [in]  传给入口函数的参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-2-查找所有使用pthread-create的地方，并处理掉"><a href="#17-2-查找所有使用pthread-create的地方，并处理掉" class="headerlink" title="17.2 查找所有使用pthread_create的地方，并处理掉"></a>17.2 查找所有使用<code>pthread_create</code>的地方，并处理掉</h3><p>找到被创建的线程入口地址，在运行态用 Arm64Writer 写入 RET，实现就地空返回。</p>
<p>在ida中，我们通过x键，查找sub_7A230的引用，然后去把线程入口函数给处理掉。</p>
<p><img src="/images/DexProtector/img_18.png" alt="img_18.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">retFunc</span>(<span class="params">parg2</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改内存保护，使其可写</span></span><br><span class="line">    <span class="title class_">Memory</span>.<span class="title function_">protect</span>(parg2, <span class="number">4</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用 Arm64Writer 写入 &#x27;ret&#x27; 指令</span></span><br><span class="line">    <span class="keyword">var</span> writer = <span class="keyword">new</span> <span class="title class_">Arm64Writer</span>(parg2);</span><br><span class="line">    writer.<span class="title function_">putRet</span>();</span><br><span class="line">    writer.<span class="title function_">flush</span>();</span><br><span class="line">    writer.<span class="title function_">dispose</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ret &quot;</span> + parg2 + <span class="string">&quot; success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5A708</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5BE28</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D1A4</span>))</span><br><span class="line"><span class="title function_">retFunc</span>(libanon.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0x5D710</span>))</span><br></pre></td></tr></table></figure>
<p>最终结果，没有那么多线程检测一直刷了，看着比较舒服。<br><img src="/images/DexProtector/img_20.png" alt="img_20.png"><br><img src="/images/DexProtector/img_19.png" alt="img_19.png"></p>
<h1 id="结论回顾（方法-结论）"><a href="#结论回顾（方法-结论）" class="headerlink" title="结论回顾（方法 &gt; 结论）"></a>结论回顾（方法 &gt; 结论）</h1><p>入口选择决定成败：相对直接 Hook System.loadLibrary，从 __loader_android_dlopen_ext 切入能更早获得“真实装载面”的证据；</p>
<p>匿名映射段是关键战场：JNI_OnLoad → 函数指针 → 匿名段 这一跳，要求在内存态完成 dump 与“仅 text 段”的最小可用反汇编；</p>
<p>校验链路是主线：识别 xxHash&#x2F;SHA256&#x2F;HMAC 的组合与落点，用等式化替换与调用点定位做最小侵入的试探；</p>
<p>系统性缩小问题空间：从可卸载点开始做二分排除，定位到刷 maps 的线程入口，补丁而非大面积禁用，以减小误伤面与回归压力。</p>
<h2 id="限制与风险"><a href="#限制与风险" class="headerlink" title="限制与风险"></a>限制与风险</h2><p>结论对ROM&#x2F;内核&#x2F;ART 版本敏感：不同 SoC 与 API Level 下，maps 命名、权限组合、linker 细节均可能影响可见性与时序。</p>
<p>某些对抗属于“只对当下样本有效”：比如栈上&#x2F;堆上指针偏移、匿名段大小、HMAC 初始材料位置等，需在发布后持续校验与回归。</p>
<p>工具链差异：Zygisk Frida Gadget 与纯 frida-server 的可见性与时序差异</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fyrlove.github.io/2025/11/20/DexProtector/" data-id="cuidWNGqvlcrBNMLwWcIujsEL" data-title="从零开始绕过 DexProtector 加固的 Frida 检测" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">一月 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">十一月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/12/DexProtector2/">从零开始绕过 DexProtector 加固的 Frida 检测（二）</a>
          </li>
        
          <li>
            <a href="/2025/11/20/DexProtector/">从零开始绕过 DexProtector 加固的 Frida 检测</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 fyrlove<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>